{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Some Documentation page \u00b6","title":"Some Documentation page"},{"location":"#some-documentation-page","text":"","title":"Some Documentation page"},{"location":"page_1/","text":"Page 1 \u00b6 Danger some: data","title":"Page 1"},{"location":"page_1/#page-1","text":"Danger some: data","title":"Page 1"},{"location":"IDE/","text":"The IDE \u00b6 The IDE (or Integrated Development Environment) has been written especially for Student Robotics. It is a web-based IDE which means all work needs to be done with an internet connection. This is a good thing, though: all of your code will be on our server so you don't need to worry about losing your memory stick. (But please don't lose it!) To get to the IDE, there is a link in the menu above. You can also click here . Features \u00b6 Within the IDE, the code you write is organised into projects , each of which can contain as many files or folders as you like. You can work on as many projects as you like, but you can only run the code from one project at a time your the robot. To help you find things, the IDE also lets you search through the things it knows about. Each project within the IDE is stored in a version control repository. This means that you can go back to how the project was yesterday, last week, or whenever you'd previously saved it. The IDE is also the place where you can edit your team's page on Student Robotics' website.","title":"IDE"},{"location":"IDE/#the-ide","text":"The IDE (or Integrated Development Environment) has been written especially for Student Robotics. It is a web-based IDE which means all work needs to be done with an internet connection. This is a good thing, though: all of your code will be on our server so you don't need to worry about losing your memory stick. (But please don't lose it!) To get to the IDE, there is a link in the menu above. You can also click here .","title":"The IDE"},{"location":"IDE/#features","text":"Within the IDE, the code you write is organised into projects , each of which can contain as many files or folders as you like. You can work on as many projects as you like, but you can only run the code from one project at a time your the robot. To help you find things, the IDE also lets you search through the things it knows about. Each project within the IDE is stored in a version control repository. This means that you can go back to how the project was yesterday, last week, or whenever you'd previously saved it. The IDE is also the place where you can edit your team's page on Student Robotics' website.","title":"Features"},{"location":"IDE/code_checking/","text":"Code Checking \u00b6 Your code is checked automatically every time you click Export Project in the Projects tab. If you wish to check code before you export it, you can do so by clicking the Check Code button also on the Projects tab. If there are any errors with your code, the code checker will present a warning offering you the chance to view the errors. The errors checking is done by running your code past a number of checkers, including pylint . The check will check all your imported modules, so if you've written your code across multiple files (and imported them appropriately) you only need to run the check against robot.py \u2013 the checking will find all the used files and check them too. On the errors page, you will see a listing of all the files that have been checked and found to have errors in them. You can click on the name of each file to view it, or you can double-click on a particular error to be taken to the error's location in the source. The formatting of the errors is as follows: line: [severity] message So an error on the second line of a file, where you've used a variable without declaring it, such as: import sr.robot print bacon Would show up as: 2: [E] Undefined variable 'bacon'","title":"Code Checking"},{"location":"IDE/code_checking/#code-checking","text":"Your code is checked automatically every time you click Export Project in the Projects tab. If you wish to check code before you export it, you can do so by clicking the Check Code button also on the Projects tab. If there are any errors with your code, the code checker will present a warning offering you the chance to view the errors. The errors checking is done by running your code past a number of checkers, including pylint . The check will check all your imported modules, so if you've written your code across multiple files (and imported them appropriately) you only need to run the check against robot.py \u2013 the checking will find all the used files and check them too. On the errors page, you will see a listing of all the files that have been checked and found to have errors in them. You can click on the name of each file to view it, or you can double-click on a particular error to be taken to the error's location in the source. The formatting of the errors is as follows: line: [severity] message So an error on the second line of a file, where you've used a variable without declaring it, such as: import sr.robot print bacon Would show up as: 2: [E] Undefined variable 'bacon'","title":"Code Checking"},{"location":"IDE/creating_a_project/","text":"Creating a New Project \u00b6 Organising completely different versions of code (i.e. versions that aren't just changes of one another) can be done using multiple projects. You can only run one project on your robot at a time. To create a new project, navigate to the Project tab and click on the New Project button. You will be presented with a dialogue box asking for the project name (it's best if it's meaningful). Once you've given it a name, click Save and you've got a shiny new project to play with.","title":"Creating a Project"},{"location":"IDE/creating_a_project/#creating-a-new-project","text":"Organising completely different versions of code (i.e. versions that aren't just changes of one another) can be done using multiple projects. You can only run one project on your robot at a time. To create a new project, navigate to the Project tab and click on the New Project button. You will be presented with a dialogue box asking for the project name (it's best if it's meaningful). Once you've given it a name, click Save and you've got a shiny new project to play with.","title":"Creating a New Project"},{"location":"IDE/finding_things/","text":"Finding things in the IDE \u00b6 Even when organised neatly into projects , it can sometimes be hard to remember exactly where a particular piece of code or comment is. To help with this, the IDE has a search function that can look through all of your code as well as file and project names. How to search \u00b6 Searches are done using the search page, which can be launched from the shortcuts menu. Initially, the search page will just have some search controls. You can start a search using the button, or by pressing enter once you've typed a query. Searches will look for the entire phrase, appearing exactly as typed, anywhere in the name of a project, a file or in the content of a file. Results will appear incrementally as they are found, and will be categorised by where they were found. For example, the following search for \"bacon\" found a project, a file and several mentions inside files:","title":"Finding things in the IDE"},{"location":"IDE/finding_things/#finding-things-in-the-ide","text":"Even when organised neatly into projects , it can sometimes be hard to remember exactly where a particular piece of code or comment is. To help with this, the IDE has a search function that can look through all of your code as well as file and project names.","title":"Finding things in the IDE"},{"location":"IDE/finding_things/#how-to-search","text":"Searches are done using the search page, which can be launched from the shortcuts menu. Initially, the search page will just have some search controls. You can start a search using the button, or by pressing enter once you've typed a query. Searches will look for the entire phrase, appearing exactly as typed, anywhere in the name of a project, a file or in the content of a file. Results will appear incrementally as they are found, and will be categorised by where they were found. For example, the following search for \"bacon\" found a project, a file and several mentions inside files:","title":"How to search"},{"location":"IDE/getting_code_on_the_robot/","text":"Getting Code on the Robot \u00b6 It is possible to plug the memory stick into your robot after it has been turned on. You can also pull the stick out of your robot while it's powered up, change the code and plug it back in. The new code should load and will run when you press the button. To get the code onto your robot, you'll need to use the a FAT \u2010formatted memory stick (the most common file system used on memory sticks and they usually come pre\u2010formatted), such as the one provided for you in your kit. The code is transferred from the IDE to the memory stick, and then the memory stick is plugged into the robot's USB hub. You can follow these steps when you've got some code you'd like to run: On the Projects tab, click Export Project (or press Ctrl+E). This will check your code, then offer a file for download. Save the file ( robot.zip ) to the root folder of the memory stick (as in F:\\ or H:\\ or whatever the drive letter is for you) Safely remove the memory stick Plug it into your robot's USB hub Now you can turn on your robot (or kit) and press the run button. Errors and the output of your print statements will be written to the log file . You can also view the log output live by connceting to your robot's WiFi . To re-run your program, simply remove the USB stick and plug it back in again. There's no need to restart the robot.","title":"Getting Code on the Robot"},{"location":"IDE/getting_code_on_the_robot/#getting-code-on-the-robot","text":"It is possible to plug the memory stick into your robot after it has been turned on. You can also pull the stick out of your robot while it's powered up, change the code and plug it back in. The new code should load and will run when you press the button. To get the code onto your robot, you'll need to use the a FAT \u2010formatted memory stick (the most common file system used on memory sticks and they usually come pre\u2010formatted), such as the one provided for you in your kit. The code is transferred from the IDE to the memory stick, and then the memory stick is plugged into the robot's USB hub. You can follow these steps when you've got some code you'd like to run: On the Projects tab, click Export Project (or press Ctrl+E). This will check your code, then offer a file for download. Save the file ( robot.zip ) to the root folder of the memory stick (as in F:\\ or H:\\ or whatever the drive letter is for you) Safely remove the memory stick Plug it into your robot's USB hub Now you can turn on your robot (or kit) and press the run button. Errors and the output of your print statements will be written to the log file . You can also view the log output live by connceting to your robot's WiFi . To re-run your program, simply remove the USB stick and plug it back in again. There's no need to restart the robot.","title":"Getting Code on the Robot"},{"location":"IDE/good_commit_messages/","text":"Writing Good Commit Messages \u00b6 Writing good commit messages is easy; sadly, writing lazy ones is even easier. With a bit of discipline, though, it will become natural over time. There are 2 parts to a good commit message: a summary of what you've done an explanation as to why you've done it or what problem it solves And there should be a blank line between them. Here's an example: Added function to get nearest blob of colour A refactoring that returns a blob object that is the nearest one visible to the vision software; makes blob selection/targeting easier. How much you should write depends on how much code you've written. More information on what to write can be found on this website . It is good practice to produce small commits that do just one thing. If you need more than one line (less than 80 characters) to summarise the change, then the commit does too much! Although not essential in the IDE it is a good idea to format your commit messages in a certain way. As mentioned above you should leave a blank line between the summary and the main message, this website explains the reasoning behind this and many other commit message formatting conventions.","title":"Writing Good Commit Messages"},{"location":"IDE/good_commit_messages/#writing-good-commit-messages","text":"Writing good commit messages is easy; sadly, writing lazy ones is even easier. With a bit of discipline, though, it will become natural over time. There are 2 parts to a good commit message: a summary of what you've done an explanation as to why you've done it or what problem it solves And there should be a blank line between them. Here's an example: Added function to get nearest blob of colour A refactoring that returns a blob object that is the nearest one visible to the vision software; makes blob selection/targeting easier. How much you should write depends on how much code you've written. More information on what to write can be found on this website . It is good practice to produce small commits that do just one thing. If you need more than one line (less than 80 characters) to summarise the change, then the commit does too much! Although not essential in the IDE it is a good idea to format your commit messages in a certain way. As mentioned above you should leave a blank line between the summary and the main message, this website explains the reasoning behind this and many other commit message formatting conventions.","title":"Writing Good Commit Messages"},{"location":"IDE/shortcuts_menu/","text":"The shortcuts menu in the IDE \u00b6 There are a number of IDE features that aren't needed all the time, but which are useful to have when you do want them. These are kept in the shortcuts menu , which is always the left-most tab in the tab-bar. Once expanded, the menu offers buttons to create a new file, start a search , change IDE settings , edit your Team Status or view information about the IDE itself.","title":"The shortcuts menu in the IDE"},{"location":"IDE/shortcuts_menu/#the-shortcuts-menu-in-the-ide","text":"There are a number of IDE features that aren't needed all the time, but which are useful to have when you do want them. These are kept in the shortcuts menu , which is always the left-most tab in the tab-bar. Once expanded, the menu offers buttons to create a new file, start a search , change IDE settings , edit your Team Status or view information about the IDE itself.","title":"The shortcuts menu in the IDE"},{"location":"IDE/user_settings/","text":"User Settings in the IDE \u00b6 The IDE contains a small number of behaviours that can be configured via user set preferences. These can be changed on the settings page of the IDE, which also offers descriptions of what each one does. The settings page is available via the shortcuts menu in the tab-bar: Some settings are only available (and will otherwise appear disabled) when you select a given option in another setting. One example of this is the Project to load setting, whose value only has any meaning if you select \"Specify manually\" in the Project Autoload setting. Don't forget to save your settings after making any changes!","title":"User configurable settings in the IDE"},{"location":"IDE/user_settings/#user-settings-in-the-ide","text":"The IDE contains a small number of behaviours that can be configured via user set preferences. These can be changed on the settings page of the IDE, which also offers descriptions of what each one does. The settings page is available via the shortcuts menu in the tab-bar: Some settings are only available (and will otherwise appear disabled) when you select a given option in another setting. One example of this is the Project to load setting, whose value only has any meaning if you select \"Specify manually\" in the Project Autoload setting. Don't forget to save your settings after making any changes!","title":"User Settings in the IDE"},{"location":"IDE/version_control/","text":"Version Control \u00b6 Each project within the IDE is stored within a git repository. This means that whenever you save a change to a file, instead of just overwriting its contents the IDE saves the new content of the file (plus the message used to describe it) as a new version . Thankfully, instead of adding an ever-increasing number to the end of the file-name, this is done in a manner that stores all the \"old\" versions out of the way, leaving your \"working copy\" with just the version that you want to see (usually the latest). The collection of changes made to a file or project are known as its history . Seeing a list of changes to a file \u00b6 If you want to see a list of changes made to a file, select the file in the file list (hold Ctrl and click the file name) and then click the \"View log\" link on the left. This will open the log page for the selected file: From here, you can choose to view the whole file at particular point in the history, see the actual line changes that a particular commit made, or even revert the content of the file to a previous state. Undoing changes to a file \u00b6 If you need to \"undo\" a set of changes to a file, perhaps because they break something, then this can be done from the log page for the file. You simply need to select the revision that you want to go back to, and click the \"Revert To\" button. This will undo all the changes since the selected revision, and store the resulting change as a new version. Note that as a result, you will still be able to see the \"undone\" versions in the history, but the changes they introduced will no longer be present in the file. Seeing an old version of a project \u00b6 If you want to see the contents of a project at a given time in the past, open the project and then use the calender in the bottom left of the projects page: The dates with blue backgrounds are days on which changes were made, and the date in bold is the current date. Clicking on a day that has changes will cause the versions for that day to be shown in the drop-down box. The details include the revision id (the letters and numbers on the left), the person that made the change, the message they gave and the time the change was made. Choosing a version from the drop-down will cause the project page to show the project as it was immediately following the selected change, and if you open any files at this point, their content will also be that for the chosen revision. To get back to seeing the \"current\" version, simply select the \"HEAD\" option in the drop-down. The projects page will then continue to show the current state of the project","title":"Version Control in the IDE"},{"location":"IDE/version_control/#version-control","text":"Each project within the IDE is stored within a git repository. This means that whenever you save a change to a file, instead of just overwriting its contents the IDE saves the new content of the file (plus the message used to describe it) as a new version . Thankfully, instead of adding an ever-increasing number to the end of the file-name, this is done in a manner that stores all the \"old\" versions out of the way, leaving your \"working copy\" with just the version that you want to see (usually the latest). The collection of changes made to a file or project are known as its history .","title":"Version Control"},{"location":"IDE/version_control/#seeing-a-list-of-changes-to-a-file","text":"If you want to see a list of changes made to a file, select the file in the file list (hold Ctrl and click the file name) and then click the \"View log\" link on the left. This will open the log page for the selected file: From here, you can choose to view the whole file at particular point in the history, see the actual line changes that a particular commit made, or even revert the content of the file to a previous state.","title":"Seeing a list of changes to a file"},{"location":"IDE/version_control/#undoing-changes-to-a-file","text":"If you need to \"undo\" a set of changes to a file, perhaps because they break something, then this can be done from the log page for the file. You simply need to select the revision that you want to go back to, and click the \"Revert To\" button. This will undo all the changes since the selected revision, and store the resulting change as a new version. Note that as a result, you will still be able to see the \"undone\" versions in the history, but the changes they introduced will no longer be present in the file.","title":"Undoing changes to a file"},{"location":"IDE/version_control/#seeing-an-old-version-of-a-project","text":"If you want to see the contents of a project at a given time in the past, open the project and then use the calender in the bottom left of the projects page: The dates with blue backgrounds are days on which changes were made, and the date in bold is the current date. Clicking on a day that has changes will cause the versions for that day to be shown in the drop-down box. The details include the revision id (the letters and numbers on the left), the person that made the change, the message they gave and the time the change was made. Choosing a version from the drop-down will cause the project page to show the project as it was immediately following the selected change, and if you open any files at this point, their content will also be that for the chosen revision. To get back to seeing the \"current\" version, simply select the \"HEAD\" option in the drop-down. The projects page will then continue to show the current state of the project","title":"Seeing an old version of a project"},{"location":"kit/","text":"Kit \u00b6 The Student Robotics kit is lent, free of charge, to each team and consists of various modules designed by us along with some ancillary parts to allow easy use of the modules. The Modules \u00b6 We provide modules, known as 'boards', in each kit. These modules can be plugged together and as a whole form the basis for controlling your robot. The boards provided are as follows; more details can be found on their individual pages. Brain Board Power Board Motor Board x2 Ruggeduino (including two screw shields) Servo Board The WiFi \u00b6 The kit can be controlled over WiFi . You can use any device to connect to the WiFi. Ancillary Parts \u00b6 As well as the aforementioned boards the kit also contains the following items. Part Qty Specification Part Number(s) Notes Battery Charger Supply 1 12V 5A N/A Battery Charger 1 iMAX B6 or HobbyKing E4 N/A Documentation is available on charging the batteries using this USB Hub 2 7-Port StarTech ST7202USBGB The hub does not require a power cable USB WiFi Adapter 2 300Mbps Mini Wireless N USB Adapter TP-Link TL-WN823N USB Memory Stick 1 Kingston Datatraveler G2 2GB or G3 8GB N/A (discontinued) Standard USB cable 3 Standard USB A to B connector N/A For connecting the ruggeduino (via a hub) and USB hubs to the ODROID Micro USB cable 5 Standard USB A to Micro USB B N/A For connecting the motor boards, servo boards and power board to the ODROID Red Hook-up Wire 1 2.5m 0.5mm 2 4A RS 361-614 General purpose wire Black Hook-up Wire 1 2.5m 0.5mm 2 4A RS 361-579 General purpose wire Blue Hook-up Wire 1 2.5m 0.5mm 2 4A RS 361-585 General purpose wire Yellow Hook-up Wire 1 2.5m 0.5mm 2 4A RS 361-636 General purpose wire Blue Power Wire 1 1.8m 1mm 2 10A RS 361-721 To connect motors to the motor boards Red Power Wire 1 1.8m 1mm 2 10A RS 361-759 To connect power from the power board to the motor/servo boards Black Power Wire 1 1.8m 1mm 2 10A RS 361-715 To connect power from the power board to the motor/servo boards CamCon 10 2 way 7.5mm 12A Farnell 3882275 To connect 12V from the power board to the motor and servo boards MiniCamCon 7 2 way 5mm 12A Farnell 3881854 To connect motors to the motor boards, and to connect an external power switch MicroCamCon 1 2 way 3.81mm 12A Farnell 1717047 To connect a 5V component to the power board or to connect an external start button USB Webcam 1 Either Logitech C500 or Logitech C270 Ebuyer 230435 ODROID Power Cable 1 DC Plug and Cable Assembly with MicroCamCon G138960965859 Battery (LiPo) 2 11.1V 2.2Ah Lithium Polymer N/A Please read the documentation for storage and usage information Battery Bag 1 HPI Plazma Pouch Lipo Safe Bag (18x22cm) or Overlander Lipo Safe Sack HPI 101289 0000153 Batteries should always be stored in the battery bag Screwdriver 1 Duratool Precision 2.5mm Slot Screwdriver Farnell 2103271","title":"Kit"},{"location":"kit/#kit","text":"The Student Robotics kit is lent, free of charge, to each team and consists of various modules designed by us along with some ancillary parts to allow easy use of the modules.","title":"Kit"},{"location":"kit/#the-modules","text":"We provide modules, known as 'boards', in each kit. These modules can be plugged together and as a whole form the basis for controlling your robot. The boards provided are as follows; more details can be found on their individual pages. Brain Board Power Board Motor Board x2 Ruggeduino (including two screw shields) Servo Board","title":"The Modules"},{"location":"kit/#the-wifi","text":"The kit can be controlled over WiFi . You can use any device to connect to the WiFi.","title":"The WiFi"},{"location":"kit/#ancillary-parts","text":"As well as the aforementioned boards the kit also contains the following items. Part Qty Specification Part Number(s) Notes Battery Charger Supply 1 12V 5A N/A Battery Charger 1 iMAX B6 or HobbyKing E4 N/A Documentation is available on charging the batteries using this USB Hub 2 7-Port StarTech ST7202USBGB The hub does not require a power cable USB WiFi Adapter 2 300Mbps Mini Wireless N USB Adapter TP-Link TL-WN823N USB Memory Stick 1 Kingston Datatraveler G2 2GB or G3 8GB N/A (discontinued) Standard USB cable 3 Standard USB A to B connector N/A For connecting the ruggeduino (via a hub) and USB hubs to the ODROID Micro USB cable 5 Standard USB A to Micro USB B N/A For connecting the motor boards, servo boards and power board to the ODROID Red Hook-up Wire 1 2.5m 0.5mm 2 4A RS 361-614 General purpose wire Black Hook-up Wire 1 2.5m 0.5mm 2 4A RS 361-579 General purpose wire Blue Hook-up Wire 1 2.5m 0.5mm 2 4A RS 361-585 General purpose wire Yellow Hook-up Wire 1 2.5m 0.5mm 2 4A RS 361-636 General purpose wire Blue Power Wire 1 1.8m 1mm 2 10A RS 361-721 To connect motors to the motor boards Red Power Wire 1 1.8m 1mm 2 10A RS 361-759 To connect power from the power board to the motor/servo boards Black Power Wire 1 1.8m 1mm 2 10A RS 361-715 To connect power from the power board to the motor/servo boards CamCon 10 2 way 7.5mm 12A Farnell 3882275 To connect 12V from the power board to the motor and servo boards MiniCamCon 7 2 way 5mm 12A Farnell 3881854 To connect motors to the motor boards, and to connect an external power switch MicroCamCon 1 2 way 3.81mm 12A Farnell 1717047 To connect a 5V component to the power board or to connect an external start button USB Webcam 1 Either Logitech C500 or Logitech C270 Ebuyer 230435 ODROID Power Cable 1 DC Plug and Cable Assembly with MicroCamCon G138960965859 Battery (LiPo) 2 11.1V 2.2Ah Lithium Polymer N/A Please read the documentation for storage and usage information Battery Bag 1 HPI Plazma Pouch Lipo Safe Bag (18x22cm) or Overlander Lipo Safe Sack HPI 101289 0000153 Batteries should always be stored in the battery bag Screwdriver 1 Duratool Precision 2.5mm Slot Screwdriver Farnell 2103271","title":"Ancillary Parts"},{"location":"kit/assembly/","text":"Kit Assembly \u00b6 The Student Robotics kit contains a number of separate modules which must be connected together to be usable to control your robot. Preparation \u00b6 The power board contains a connector for an external On|Off switch. If you do not intend to connect a switch then you must still make this connection. You can do this by connecting a short loop of wire between the two terminals of a suitable CamCon and placing it in the external On|Off port. Connections \u00b6 Each of the modules in the kit needs to be provided with both a control signal and power in order to operate. All the boards use USB to connect to the Brain Board so it can tell them what to do. If you run out of USB ports on the Brain Board itself, then you can use the provided USB hubs to provide more ports. Most of the boards (with the exception of the Ruggeduino ) also need an additional power connection. This should be provided from the Power Board . The following table summarises the connections which need to be made for each board. Board Power Brain Board 5V, using the provided cable Power Board 12V, via the yellow XT60 to the battery Motor Board 12V Ruggeduino via USB Servo Board 12V In order to connect the Motor and Servo Boards to the Power Board, you will need to create a power cables. This should be done using the provided power wire (this is the thicker wire provided in the kit) and a pair of green CamCon connectors. When creating your power cables be sure to refer to the pages for each board so that you connect the wires the right way around. In our diagrams, the + outputs from the the Power Board should be connected to the + inputs on the board being powered. Video \u00b6 The following video contains an overview which covers the brain board , power board and a motor board .","title":"Kit Assembly"},{"location":"kit/assembly/#kit-assembly","text":"The Student Robotics kit contains a number of separate modules which must be connected together to be usable to control your robot.","title":"Kit Assembly"},{"location":"kit/assembly/#preparation","text":"The power board contains a connector for an external On|Off switch. If you do not intend to connect a switch then you must still make this connection. You can do this by connecting a short loop of wire between the two terminals of a suitable CamCon and placing it in the external On|Off port.","title":"Preparation"},{"location":"kit/assembly/#connections","text":"Each of the modules in the kit needs to be provided with both a control signal and power in order to operate. All the boards use USB to connect to the Brain Board so it can tell them what to do. If you run out of USB ports on the Brain Board itself, then you can use the provided USB hubs to provide more ports. Most of the boards (with the exception of the Ruggeduino ) also need an additional power connection. This should be provided from the Power Board . The following table summarises the connections which need to be made for each board. Board Power Brain Board 5V, using the provided cable Power Board 12V, via the yellow XT60 to the battery Motor Board 12V Ruggeduino via USB Servo Board 12V In order to connect the Motor and Servo Boards to the Power Board, you will need to create a power cables. This should be done using the provided power wire (this is the thicker wire provided in the kit) and a pair of green CamCon connectors. When creating your power cables be sure to refer to the pages for each board so that you connect the wires the right way around. In our diagrams, the + outputs from the the Power Board should be connected to the + inputs on the board being powered.","title":"Connections"},{"location":"kit/assembly/#video","text":"The following video contains an overview which covers the brain board , power board and a motor board .","title":"Video"},{"location":"kit/brain_board/","text":"Brain Board \u00b6 The Odroid U3 Brain Board provided with your kit is what runs the code you write and controls the other peripheral boards. It can be controlled remotely over WiFi .","title":"Brain Board"},{"location":"kit/brain_board/#brain-board","text":"The Odroid U3 Brain Board provided with your kit is what runs the code you write and controls the other peripheral boards. It can be controlled remotely over WiFi .","title":"Brain Board"},{"location":"kit/motor_board/","text":"Motor Board \u00b6 The Motor Board can be used to control two 12V DC motors. Your kit contains two of these boards to allow you to control up to four motors. These can be used for moving your robot, although don't feel you are limited to using them for this purpose. The speed and direction of the two outputs are controlled independently through the USB interface. The USB interface is isolated from the rest of the board to prevent damage to the host in the case of a board failure. Due to this isolation the board must have power applied to the power connector, from the motor rail on the power board, to function. If the board does not have power applied to the power connector then the kit will report that there is a problem with the motor board. Board Diagram \u00b6 Indicators \u00b6 LED Meaning Initial power-up state Power The board is powered On M{0,1} Speed/Direction Brightness indicates speed, colour indicates direction Off USB Power The USB interface is powered On USB Data Data is being transferred to/from the board Off Case Dimensions \u00b6 The case measures 70x84x20mm. Don't forget that the cables will stick out. Specification \u00b6 Parameter Value Nominal input voltage 11.1V \u00b1 15% Absolute maximum input voltage 16V Minimum input voltage 9V Output voltage 11.1V \u00b1 15% Continuous output current per channel 10A Peak output current [^1] 20A UART connection voltage [^2] 3.3\u20135V [^1]: Can be sustained for 1 second, on a single channel. [^2]: If the board is controlled solely via the UART connection, this voltage must be supplied via the UART connector. Designs \u00b6 You can access the schematics and source code of the firmware on the motor board in the following places. You do not need this information to use the board but it may be of interest to some people. Full Schematics Firmware Source Hardware Designs","title":"Motor Board"},{"location":"kit/motor_board/#motor-board","text":"The Motor Board can be used to control two 12V DC motors. Your kit contains two of these boards to allow you to control up to four motors. These can be used for moving your robot, although don't feel you are limited to using them for this purpose. The speed and direction of the two outputs are controlled independently through the USB interface. The USB interface is isolated from the rest of the board to prevent damage to the host in the case of a board failure. Due to this isolation the board must have power applied to the power connector, from the motor rail on the power board, to function. If the board does not have power applied to the power connector then the kit will report that there is a problem with the motor board.","title":"Motor Board"},{"location":"kit/motor_board/#board-diagram","text":"","title":"Board Diagram"},{"location":"kit/motor_board/#indicators","text":"LED Meaning Initial power-up state Power The board is powered On M{0,1} Speed/Direction Brightness indicates speed, colour indicates direction Off USB Power The USB interface is powered On USB Data Data is being transferred to/from the board Off","title":"Indicators"},{"location":"kit/motor_board/#case-dimensions","text":"The case measures 70x84x20mm. Don't forget that the cables will stick out.","title":"Case Dimensions"},{"location":"kit/motor_board/#specification","text":"Parameter Value Nominal input voltage 11.1V \u00b1 15% Absolute maximum input voltage 16V Minimum input voltage 9V Output voltage 11.1V \u00b1 15% Continuous output current per channel 10A Peak output current [^1] 20A UART connection voltage [^2] 3.3\u20135V [^1]: Can be sustained for 1 second, on a single channel. [^2]: If the board is controlled solely via the UART connection, this voltage must be supplied via the UART connector.","title":"Specification"},{"location":"kit/motor_board/#designs","text":"You can access the schematics and source code of the firmware on the motor board in the following places. You do not need this information to use the board but it may be of interest to some people. Full Schematics Firmware Source Hardware Designs","title":"Designs"},{"location":"kit/power_board/","text":"Power Board \u00b6 The Power Board distributes power to the SR kit from the battery. It provides six individual general-purpose power outputs along with a separate power connector for the Brain Board. It also holds the internal On|Off switch for the whole robot as well as the Start button which is used to start your robot code running. Board Diagram \u00b6 Connectors \u00b6 There are six power output connectors on the board, labelled L0\u2013L3, H0, and H1. These are enabled when your robot code is started, and supply around 11.1V (\u00b115%). They should be used to connect to the motor and servo board power inputs. The \"H\" connectors will supply more current than the \"L\" connectors. The 5V connectors can be used to connect low-current devices that take 5V inputs, such as the Brain Board. There is also a Micro USB B connector which should be used to connect the Brain Board for control of the power board. Finally, there are connectors for external Start and On|Off switches. You may connect any push-to-make latching switch for the On|Off button, or a push-to-make button for the start button. If you intend to use only the internal On|Off switch, you must connect a CamCon to the On|Off connector with a wire connecting one pin to the other pin on the same connector. Indicators \u00b6 LED Meaning Initial power-up state PWR|FLAT Green when powered Flashing red and green when the battery is low Green 5V Green when 5V is being supplied Green H0-1, L0-3 Green when the output is on [^1] Red when the output's current limit is reached Off RUN|ERROR Orange on power-up, or USB reset Flashing green when ready to run Solid green when running or booting Orange [^1]: The outputs only turn on when your program runs (specifically, when the Robot object is created). On power-up, the Power Board will emit some beeps, which are related to the version of the firmware it has installed. If the Power Board starts beeping (and all the outputs turn off) then this means that the whole board's current limit has been triggered. Controls \u00b6 Control Use ON|OFF Turns the power board on, when used in conjunction with an external switch START Starts your program (can be used instead of the robot WiFi interface) Case Dimensions \u00b6 The case measures 83x99x24mm. Don't forget that the cables will stick out. Specification \u00b6 Parameter Value Main battery fuse current 40A Overall current limit[^2] 30A High current outputs (H0-1) 20A Low current outputs (L0-3) 10A Motor rail output voltage (nominal) 11.1V \u00b1 15% Maximum output current per 5V channel 1A [^2]: If overall current limit is exceeded, the Power Board will turn off and start beeping. Designs \u00b6 You can access the schematics and source code of the firmware for the power board in the following places. You do not need this information to use the board but it may be of interest to some people. Full Schematics Firmware source Hardware designs","title":"Power Board"},{"location":"kit/power_board/#power-board","text":"The Power Board distributes power to the SR kit from the battery. It provides six individual general-purpose power outputs along with a separate power connector for the Brain Board. It also holds the internal On|Off switch for the whole robot as well as the Start button which is used to start your robot code running.","title":"Power Board"},{"location":"kit/power_board/#board-diagram","text":"","title":"Board Diagram"},{"location":"kit/power_board/#connectors","text":"There are six power output connectors on the board, labelled L0\u2013L3, H0, and H1. These are enabled when your robot code is started, and supply around 11.1V (\u00b115%). They should be used to connect to the motor and servo board power inputs. The \"H\" connectors will supply more current than the \"L\" connectors. The 5V connectors can be used to connect low-current devices that take 5V inputs, such as the Brain Board. There is also a Micro USB B connector which should be used to connect the Brain Board for control of the power board. Finally, there are connectors for external Start and On|Off switches. You may connect any push-to-make latching switch for the On|Off button, or a push-to-make button for the start button. If you intend to use only the internal On|Off switch, you must connect a CamCon to the On|Off connector with a wire connecting one pin to the other pin on the same connector.","title":"Connectors"},{"location":"kit/power_board/#indicators","text":"LED Meaning Initial power-up state PWR|FLAT Green when powered Flashing red and green when the battery is low Green 5V Green when 5V is being supplied Green H0-1, L0-3 Green when the output is on [^1] Red when the output's current limit is reached Off RUN|ERROR Orange on power-up, or USB reset Flashing green when ready to run Solid green when running or booting Orange [^1]: The outputs only turn on when your program runs (specifically, when the Robot object is created). On power-up, the Power Board will emit some beeps, which are related to the version of the firmware it has installed. If the Power Board starts beeping (and all the outputs turn off) then this means that the whole board's current limit has been triggered.","title":"Indicators"},{"location":"kit/power_board/#controls","text":"Control Use ON|OFF Turns the power board on, when used in conjunction with an external switch START Starts your program (can be used instead of the robot WiFi interface)","title":"Controls"},{"location":"kit/power_board/#case-dimensions","text":"The case measures 83x99x24mm. Don't forget that the cables will stick out.","title":"Case Dimensions"},{"location":"kit/power_board/#specification","text":"Parameter Value Main battery fuse current 40A Overall current limit[^2] 30A High current outputs (H0-1) 20A Low current outputs (L0-3) 10A Motor rail output voltage (nominal) 11.1V \u00b1 15% Maximum output current per 5V channel 1A [^2]: If overall current limit is exceeded, the Power Board will turn off and start beeping.","title":"Specification"},{"location":"kit/power_board/#designs","text":"You can access the schematics and source code of the firmware for the power board in the following places. You do not need this information to use the board but it may be of interest to some people. Full Schematics Firmware source Hardware designs","title":"Designs"},{"location":"kit/ruggeduino/","text":"Ruggeduino \u00b6 The Ruggeduino board allows you to connect the SR kit to your own electronics. This board is very similar to an Arduino which you may have used before. It has 14 digital I/O pins, these pins can either input or output a digital signal. 5V logic is used to interface with the Ruggeduino. The board also has 6 analogue input pins, these pins can read an analogue signal from 0 to 5V. The board has a 3.3V pin, a 5V pin and three 0V/ground pins which can be used to power external devices. If for whatever reason the board does not seem to be working pressing the reset button will reset the Ruggeduino and may solve the problem. The Ruggeduino needs only to be connected to the kit over USB as it uses this for both power and communication. Board Diagram \u00b6 Indicators \u00b6 LED Meaning Initial power-up state Power The board is powered On Data The board is transferring data Flashing Pin 13 Pin 13 is outputting 5V Off Case Dimensions \u00b6 The case alone measures 86\u271568\u271523mm(L\u2715W\u2715H) without the extra pin headers. When the Ruggeduino is fitted the whole unit measures 86\u271584\u271529mm; some screw heads may protrude from the bottom of the case by up to 2mm. Don\u2019t forget that the cables will also stick out. Specification \u00b6 Parameter Value Power Output Voltage 5V or 3.3V Maximum 5V Output Current 500mA Maximum 3.3V Output Current 350mA Maximum Current Per Output 30mA Output High Voltage 5V Output Low Voltage 0V Maximum Input Voltage 24V Maximum Measurable Input Voltage 5V Input Digital Threshold Voltage 2.5V Considerations \u00b6 As protection the Ruggeduino has a 220ohm resistor connected to each of its pins. This will need to be considered when attaching external components. For example: Normally a current limiting resistor is needed in series with a standard LED, when using the Ruggeduino to drive the LED a current limiting resistor is not required. Design \u00b6 Schematic Manufacturer's documentation","title":"Ruggeduino"},{"location":"kit/ruggeduino/#ruggeduino","text":"The Ruggeduino board allows you to connect the SR kit to your own electronics. This board is very similar to an Arduino which you may have used before. It has 14 digital I/O pins, these pins can either input or output a digital signal. 5V logic is used to interface with the Ruggeduino. The board also has 6 analogue input pins, these pins can read an analogue signal from 0 to 5V. The board has a 3.3V pin, a 5V pin and three 0V/ground pins which can be used to power external devices. If for whatever reason the board does not seem to be working pressing the reset button will reset the Ruggeduino and may solve the problem. The Ruggeduino needs only to be connected to the kit over USB as it uses this for both power and communication.","title":"Ruggeduino"},{"location":"kit/ruggeduino/#board-diagram","text":"","title":"Board Diagram"},{"location":"kit/ruggeduino/#indicators","text":"LED Meaning Initial power-up state Power The board is powered On Data The board is transferring data Flashing Pin 13 Pin 13 is outputting 5V Off","title":"Indicators"},{"location":"kit/ruggeduino/#case-dimensions","text":"The case alone measures 86\u271568\u271523mm(L\u2715W\u2715H) without the extra pin headers. When the Ruggeduino is fitted the whole unit measures 86\u271584\u271529mm; some screw heads may protrude from the bottom of the case by up to 2mm. Don\u2019t forget that the cables will also stick out.","title":"Case Dimensions"},{"location":"kit/ruggeduino/#specification","text":"Parameter Value Power Output Voltage 5V or 3.3V Maximum 5V Output Current 500mA Maximum 3.3V Output Current 350mA Maximum Current Per Output 30mA Output High Voltage 5V Output Low Voltage 0V Maximum Input Voltage 24V Maximum Measurable Input Voltage 5V Input Digital Threshold Voltage 2.5V","title":"Specification"},{"location":"kit/ruggeduino/#considerations","text":"As protection the Ruggeduino has a 220ohm resistor connected to each of its pins. This will need to be considered when attaching external components. For example: Normally a current limiting resistor is needed in series with a standard LED, when using the Ruggeduino to drive the LED a current limiting resistor is not required.","title":"Considerations"},{"location":"kit/ruggeduino/#design","text":"Schematic Manufacturer's documentation","title":"Design"},{"location":"kit/servo_board/","text":"Servo Board \u00b6 The Servo Board can be used to control up to 12 RC servos. Many devices are available that can be controlled as servos, such as RC motor speed controllers, and these can also be used with the board. Board Diagram \u00b6 Connectors \u00b6 There are 8 servo connections on the left-side of the board, and 4 on the right. Servo cables are connected vertically, with 0V (the black or brown wire) at the bottom of the board. For the servo board to operate correctly, you must connect it to the 12V power rail from the power board. A green LED will light next to the servo board 12V connector when it is correctly powered. Case Dimensions \u00b6 The case measures 68x68x21mm. Don't forget that the cables will stick out. Specification \u00b6 Parameter Value Number of servo channels 12 Nominal input voltage 11.1V \u00b1 15% Output voltage 5.5V Maximum total output current [^1] 10A [^1]: If the auxiliary input is connected, outputs 8-11 have an independent maximum current. Designs \u00b6 You can access the schematics and source code of the firmware on the servo board in the following places. You do not need this information to use the board but it may be of interest to some people. Full Schematics Firmware source Hardware designs","title":"Servo Board"},{"location":"kit/servo_board/#servo-board","text":"The Servo Board can be used to control up to 12 RC servos. Many devices are available that can be controlled as servos, such as RC motor speed controllers, and these can also be used with the board.","title":"Servo Board"},{"location":"kit/servo_board/#board-diagram","text":"","title":"Board Diagram"},{"location":"kit/servo_board/#connectors","text":"There are 8 servo connections on the left-side of the board, and 4 on the right. Servo cables are connected vertically, with 0V (the black or brown wire) at the bottom of the board. For the servo board to operate correctly, you must connect it to the 12V power rail from the power board. A green LED will light next to the servo board 12V connector when it is correctly powered.","title":"Connectors"},{"location":"kit/servo_board/#case-dimensions","text":"The case measures 68x68x21mm. Don't forget that the cables will stick out.","title":"Case Dimensions"},{"location":"kit/servo_board/#specification","text":"Parameter Value Number of servo channels 12 Nominal input voltage 11.1V \u00b1 15% Output voltage 5.5V Maximum total output current [^1] 10A [^1]: If the auxiliary input is connected, outputs 8-11 have an independent maximum current.","title":"Specification"},{"location":"kit/servo_board/#designs","text":"You can access the schematics and source code of the firmware on the servo board in the following places. You do not need this information to use the board but it may be of interest to some people. Full Schematics Firmware source Hardware designs","title":"Designs"},{"location":"kit/wifi/","text":"WiFi \u00b6 The WiFi dongles provided with your kit allow you to interface with and debug your robot. You can connect to your robot using any WiFi capable device (laptop, tablet, phone, etc.) Connecting to Your Robot \u00b6 First, ensure that the WiFi dongles supplied with your kit are plugged into your robot. Once you have the WiFi dongles connected, plug in a USB memory stick and turn your robot on. During the boot process you should notice a green LED begin to flash on one of the WiFi dongles. Your robot has now set up its very own WiFi network! It'll be called robot-XXX , where XXX is your team's TLA. You can now connect to your robot in the same way you normally connect to a WiFi network. You will need a WiFi key to be able to connect and you can find this inside any robot.zip that you have exported from the IDE. Just unzip the robot.zip and have a look inside wifi.yaml . Note that, because the information for your robot's WiFi network is stored inside the robot.zip, the WiFi network will disappear when you unplug the USB memory stick. It will reappear a few moments after you plug the USB memory stick into your robot. If you are having any problems connecting to your robot, just head on over to the forum and ask for help. Interacting With Your Robot \u00b6 Once you have a WiFi connection, visit http://robot.sr in a web browser to see the robot interface. The robot interface gives you the ability to remotely start the code on your robot, as well as view the logs. The stop button that appears after starting your code is currently not functional. Setting up the Robot's Environment \u00b6 When you first navigate to the robot interface you are presented with the Set up page. This page allows you to select the starting zone of your robot, as well as whether it is running in development mode or competition mode. Changing the starting zone allows you to test how your robot handles being started in a different zone. Changing to competition mode causes the development markers to be unreadable, and instead reads the competition markers, which are different. Therefore, you should keep your robot in development mode. You cannot use this screen when code is running. Logs Screen \u00b6 This screen allows you to see all messages from your code sent by print statements (and anything else that outputs to standard output or standard error). It will also show messages from the initialisation of the robot's hardware, as well as any errors that occurred when running your code. You can press the \"Jump to bottom\" button to scroll right to the bottom of the logs, to see the most recent entries in a long file. You can also see your robot's logs on the USB stick, in a file called log.txt .","title":"WiFi"},{"location":"kit/wifi/#wifi","text":"The WiFi dongles provided with your kit allow you to interface with and debug your robot. You can connect to your robot using any WiFi capable device (laptop, tablet, phone, etc.)","title":"WiFi"},{"location":"kit/wifi/#connecting-to-your-robot","text":"First, ensure that the WiFi dongles supplied with your kit are plugged into your robot. Once you have the WiFi dongles connected, plug in a USB memory stick and turn your robot on. During the boot process you should notice a green LED begin to flash on one of the WiFi dongles. Your robot has now set up its very own WiFi network! It'll be called robot-XXX , where XXX is your team's TLA. You can now connect to your robot in the same way you normally connect to a WiFi network. You will need a WiFi key to be able to connect and you can find this inside any robot.zip that you have exported from the IDE. Just unzip the robot.zip and have a look inside wifi.yaml . Note that, because the information for your robot's WiFi network is stored inside the robot.zip, the WiFi network will disappear when you unplug the USB memory stick. It will reappear a few moments after you plug the USB memory stick into your robot. If you are having any problems connecting to your robot, just head on over to the forum and ask for help.","title":"Connecting to Your Robot"},{"location":"kit/wifi/#interacting-with-your-robot","text":"Once you have a WiFi connection, visit http://robot.sr in a web browser to see the robot interface. The robot interface gives you the ability to remotely start the code on your robot, as well as view the logs. The stop button that appears after starting your code is currently not functional.","title":"Interacting With Your Robot"},{"location":"kit/wifi/#setting-up-the-robots-environment","text":"When you first navigate to the robot interface you are presented with the Set up page. This page allows you to select the starting zone of your robot, as well as whether it is running in development mode or competition mode. Changing the starting zone allows you to test how your robot handles being started in a different zone. Changing to competition mode causes the development markers to be unreadable, and instead reads the competition markers, which are different. Therefore, you should keep your robot in development mode. You cannot use this screen when code is running.","title":"Setting up the Robot's Environment"},{"location":"kit/wifi/#logs-screen","text":"This screen allows you to see all messages from your code sent by print statements (and anything else that outputs to standard output or standard error). It will also show messages from the initialisation of the robot's hardware, as well as any errors that occurred when running your code. You can press the \"Jump to bottom\" button to scroll right to the bottom of the logs, to see the most recent entries in a long file. You can also see your robot's logs on the USB stick, in a file called log.txt .","title":"Logs Screen"},{"location":"kit/batteries/","text":"Batteries and Charging \u00b6 The electronics kit contains two lithium-ion polymer (LiPo) batteries. These are similar to those used in laptops, and are small and light for the amount of energy they contain. This is great for your robot but it is vital to treat such a high concentration of energy with respect. If you do not, there is a serious risk of fire and injury. To avoid this, you should follow the safety information on this page closely, at all times. Your kit will come with several pieces of battery related equipment: Two 11.1V 2200mAh LiPo Batteries. One battery charger. One battery charging bag. You must not use any batteries, chargers, bags or cables not explicitly authorised by Student Robotics. If you have any doubts or wish to request permission to use a battery, charger, charging bag or battery cable not provided by Student Robotics, please contact kit@example.com . Never leave batteries unattended when they are in use or charging. Always place the batteries in the provided charging bag when charging or storing. Always follow the charging checklist precisely to make sure the charger is correctly configured. See the Charging Batteries section for more details. Always leave the charging leads connected to the battery charger at all times. Do not charge or use a damaged battery. If a battery has any cuts, nicks, exposed copper on wires or is bulging to the point of no longer being squishy, contact kit@example.com immediately. Storing Batteries \u00b6 When your batteries are not actively in use, they should be safely stored. You must disconnect the batteries from all electrical equipment, and place them in the battery charging bag. You should then store the charging bag in a safe location. If you are not going to use the batteries for a long period of time, such as more than a week, then you should charge the batteries before hand. By themselves, batteries will discharge very slowly, and over-discharging will lead to damage. We recommend that you charge all batteries to at least 70% of capacity before being stored for a long period. Operating Batteries \u00b6 To use your batteries, you must connect them to the Student Robotics power board. Do not tamper with the cable or connect the batteries to anything other than the power board (or the charger when charging). During operation, the battery is protected by over-current protection and a fuse in the power board. If any equipment is short circuited, the over-current protection will activate - protecting the battery. In extreme circumstances the fuse may blow to prevent damage to the battery. This is an important safety feature: do not , under any circumstances, bypass the fuse. The fuse is not user serviceable and if the fuse has blown then the power board must be replaced. If you suspect the fuse has blown then please contact kit@example.com straight away. Mechanical damage to a battery can be dangerous, and a puncture or large force applied to a battery causes a serious risk of fire. To avoid this, your battery should be shielded from mechanical damage while you operate it. Secure your battery to your robot, so that it does not move or fall off while the robot moves. You should also build a compartment for the battery to be placed in, so that accidental collisions do not damage the battery. Flat Batteries \u00b6 When the battery has been almost completely discharged, the Power Board will automatically turn off and the LED marked \"Power / Flat Battery Indicator\" in the diagram will flash red and green. You should immediately disconnect the battery, and begin charging it. You should keep your second battery charged, so that you can immediately switch to using it. Do not store a discharged battery for more than a few days without charging it, as it may discharge further and become damaged. Charging Batteries \u00b6 Student Robotics provides two different kinds of chargers with our kit, the iMAX B6 , and the HobbyKing HKE4 . You should only use the battery charger provided by Student Robotics to charge the batteries provided in the kit. For precise instructions on how to charge your batteries with the provided charger, please see the charger specific documentation page.","title":"Batteries and Charging"},{"location":"kit/batteries/#batteries-and-charging","text":"The electronics kit contains two lithium-ion polymer (LiPo) batteries. These are similar to those used in laptops, and are small and light for the amount of energy they contain. This is great for your robot but it is vital to treat such a high concentration of energy with respect. If you do not, there is a serious risk of fire and injury. To avoid this, you should follow the safety information on this page closely, at all times. Your kit will come with several pieces of battery related equipment: Two 11.1V 2200mAh LiPo Batteries. One battery charger. One battery charging bag. You must not use any batteries, chargers, bags or cables not explicitly authorised by Student Robotics. If you have any doubts or wish to request permission to use a battery, charger, charging bag or battery cable not provided by Student Robotics, please contact kit@example.com . Never leave batteries unattended when they are in use or charging. Always place the batteries in the provided charging bag when charging or storing. Always follow the charging checklist precisely to make sure the charger is correctly configured. See the Charging Batteries section for more details. Always leave the charging leads connected to the battery charger at all times. Do not charge or use a damaged battery. If a battery has any cuts, nicks, exposed copper on wires or is bulging to the point of no longer being squishy, contact kit@example.com immediately.","title":"Batteries and Charging"},{"location":"kit/batteries/#storing-batteries","text":"When your batteries are not actively in use, they should be safely stored. You must disconnect the batteries from all electrical equipment, and place them in the battery charging bag. You should then store the charging bag in a safe location. If you are not going to use the batteries for a long period of time, such as more than a week, then you should charge the batteries before hand. By themselves, batteries will discharge very slowly, and over-discharging will lead to damage. We recommend that you charge all batteries to at least 70% of capacity before being stored for a long period.","title":"Storing Batteries"},{"location":"kit/batteries/#operating-batteries","text":"To use your batteries, you must connect them to the Student Robotics power board. Do not tamper with the cable or connect the batteries to anything other than the power board (or the charger when charging). During operation, the battery is protected by over-current protection and a fuse in the power board. If any equipment is short circuited, the over-current protection will activate - protecting the battery. In extreme circumstances the fuse may blow to prevent damage to the battery. This is an important safety feature: do not , under any circumstances, bypass the fuse. The fuse is not user serviceable and if the fuse has blown then the power board must be replaced. If you suspect the fuse has blown then please contact kit@example.com straight away. Mechanical damage to a battery can be dangerous, and a puncture or large force applied to a battery causes a serious risk of fire. To avoid this, your battery should be shielded from mechanical damage while you operate it. Secure your battery to your robot, so that it does not move or fall off while the robot moves. You should also build a compartment for the battery to be placed in, so that accidental collisions do not damage the battery.","title":"Operating Batteries"},{"location":"kit/batteries/#flat-batteries","text":"When the battery has been almost completely discharged, the Power Board will automatically turn off and the LED marked \"Power / Flat Battery Indicator\" in the diagram will flash red and green. You should immediately disconnect the battery, and begin charging it. You should keep your second battery charged, so that you can immediately switch to using it. Do not store a discharged battery for more than a few days without charging it, as it may discharge further and become damaged.","title":"Flat Batteries"},{"location":"kit/batteries/#charging-batteries","text":"Student Robotics provides two different kinds of chargers with our kit, the iMAX B6 , and the HobbyKing HKE4 . You should only use the battery charger provided by Student Robotics to charge the batteries provided in the kit. For precise instructions on how to charge your batteries with the provided charger, please see the charger specific documentation page.","title":"Charging Batteries"},{"location":"kit/batteries/hke4_charger/","text":"HobbyKing HKE4 Chargers \u00b6 Some kits will contain a black HobbyKing HKE4 charger. This charger is simpler and easier to use than the iMAX B6 charger, while retaining all of the functionality required for charging the batteries supplied with the kit. The charging lead is cable-tied to the charger and you must not remove this cable. The charging lead is terminated with 4mm bullet connectors, which present a very high risk of shorting the battery if removed from the charger. Charger Diagram \u00b6 Charging Instructions \u00b6 These instructions must be followed every time a battery is charged. Plug in the mains adapter into the mains. Plug the mains adaptor power lead into the battery charger. Plug the charging lead and the main battery power lead together. Never, under any circumstances, remove the charging lead from the charger. Plug the balance lead from the battery into the charger. Place the battery in the charging bag. Turn the charge current knob to 2.2A (12 o'clock position). Press the Start/Stop button to begin charging. The charging process should take no longer than 1.5 hours. Once it has finished, three of the four LEDs will glow constantly green and the charger will beep for fifteen seconds. You must then: Unplug the balance lead. Unplug the battery from the charging lead, do not unplug the charging lead from the charger. Unplug the charger from the mains. Generally, the battery does not have to be charged to 100% every time you want to use it. However, before storing the battery for longer periods of time, it is best to charge it to approximately 70% because storing it with 100% charge puts stress on the battery, reducing its life.","title":"The HobbyKing HKE4 Charger"},{"location":"kit/batteries/hke4_charger/#hobbyking-hke4-chargers","text":"Some kits will contain a black HobbyKing HKE4 charger. This charger is simpler and easier to use than the iMAX B6 charger, while retaining all of the functionality required for charging the batteries supplied with the kit. The charging lead is cable-tied to the charger and you must not remove this cable. The charging lead is terminated with 4mm bullet connectors, which present a very high risk of shorting the battery if removed from the charger.","title":"HobbyKing HKE4 Chargers"},{"location":"kit/batteries/hke4_charger/#charger-diagram","text":"","title":"Charger Diagram"},{"location":"kit/batteries/hke4_charger/#charging-instructions","text":"These instructions must be followed every time a battery is charged. Plug in the mains adapter into the mains. Plug the mains adaptor power lead into the battery charger. Plug the charging lead and the main battery power lead together. Never, under any circumstances, remove the charging lead from the charger. Plug the balance lead from the battery into the charger. Place the battery in the charging bag. Turn the charge current knob to 2.2A (12 o'clock position). Press the Start/Stop button to begin charging. The charging process should take no longer than 1.5 hours. Once it has finished, three of the four LEDs will glow constantly green and the charger will beep for fifteen seconds. You must then: Unplug the balance lead. Unplug the battery from the charging lead, do not unplug the charging lead from the charger. Unplug the charger from the mains. Generally, the battery does not have to be charged to 100% every time you want to use it. However, before storing the battery for longer periods of time, it is best to charge it to approximately 70% because storing it with 100% charge puts stress on the battery, reducing its life.","title":"Charging Instructions"},{"location":"kit/batteries/imax_b6_charger/","text":"iMAX B6 Chargers \u00b6 Some kits will contain a blue iMAX B6 charger. This charger is more complex than the HobbyKing HKE4 charger and has a lot of unnecessary functionality, for this reason it is important that you follow the instructions detailed below. The charging cable is cable-tied to the charger and you must not remove this cable. The charging lead is terminated with 4mm bullet connectors, which present a very high risk of shorting the battery if removed from the charger. Charging Checklist \u00b6 This list must be followed carefully each time a battery is connected to the charger. Plug in the mains adapter and plug it into the battery charger. Connect the charging lead from the charger to the battery. Ensure you plug the lead into the charger first and the battery second to avoid risk of shorting the battery. Connect the monitoring lead from the battery to the charger. Place the battery in the charging bag. Configure the charger using the menu system as follows. After turning on the screen should show: PROGRAM SELECT LiPo BATT If it does not repeatedly press Batt.Type/Stop until it does. Press Start/Enter to select lithium battery charging. The following screen may be the first shown if the charger has been used previously. LiPo CHARGE 0.1A 3.7V(1S) Press Inc. to select Balance charging. LiPo BALANCE 2.4A 22.2V(6S) Press Start/Enter to edit the charging current. LiPo BALANCE 2.2A 11.1V(3S) The current (bottom left) should start blinking. Use the Inc. / Dec. buttons until it reads 2.2A . Press Start/Enter to store the value and to begin editing the battery voltage. Use the Inc. / Dec. buttons until it reads 11.1V(3S) . LiPo BALANCE 2.2A 11.1V(3S) Hold Start/Enter for 3 seconds to confirm. The charger will try to detect the battery. It must show: R:3SER S:3SER CONFIRM(ENTER) The important thing to note here is that the number of cells detected by the charger (R) and the number of cells set by you (S) are both 3. If either of these numbers are different immediately power down the charger and contact Student Robotics. Press Start/Enter to commence charging Li3S 2.2A 12.59V BAL 022:43 00682 The screen shows the charging current (here: 2.2A ), the current voltage (here: 12.59V ), the time elapsed (here: 22m43s ) and the energy provided to the battery (here: 682mAh ). The charger will beep when the battery is fully charged. You must then: Unplug the charger from the mains. Unplug the battery from the charging lead, do not unplug the charging lead from the charger with the battery still connected. Unplug the monitoring lead from the battery to the charger. Troubleshooting \u00b6 Charger beeps and displays CONNECTION BREAK during charging Either the charging or monitoring lead has come loose. Ensure that both are fully inserted and press the following buttons to resume charging: Batt.Type/Stop \u2192 Start/Enter for 3 seconds \u2192 Start/Enter","title":"The iMAX B6 Charger"},{"location":"kit/batteries/imax_b6_charger/#imax-b6-chargers","text":"Some kits will contain a blue iMAX B6 charger. This charger is more complex than the HobbyKing HKE4 charger and has a lot of unnecessary functionality, for this reason it is important that you follow the instructions detailed below. The charging cable is cable-tied to the charger and you must not remove this cable. The charging lead is terminated with 4mm bullet connectors, which present a very high risk of shorting the battery if removed from the charger.","title":"iMAX B6 Chargers"},{"location":"kit/batteries/imax_b6_charger/#charging-checklist","text":"This list must be followed carefully each time a battery is connected to the charger. Plug in the mains adapter and plug it into the battery charger. Connect the charging lead from the charger to the battery. Ensure you plug the lead into the charger first and the battery second to avoid risk of shorting the battery. Connect the monitoring lead from the battery to the charger. Place the battery in the charging bag. Configure the charger using the menu system as follows. After turning on the screen should show: PROGRAM SELECT LiPo BATT If it does not repeatedly press Batt.Type/Stop until it does. Press Start/Enter to select lithium battery charging. The following screen may be the first shown if the charger has been used previously. LiPo CHARGE 0.1A 3.7V(1S) Press Inc. to select Balance charging. LiPo BALANCE 2.4A 22.2V(6S) Press Start/Enter to edit the charging current. LiPo BALANCE 2.2A 11.1V(3S) The current (bottom left) should start blinking. Use the Inc. / Dec. buttons until it reads 2.2A . Press Start/Enter to store the value and to begin editing the battery voltage. Use the Inc. / Dec. buttons until it reads 11.1V(3S) . LiPo BALANCE 2.2A 11.1V(3S) Hold Start/Enter for 3 seconds to confirm. The charger will try to detect the battery. It must show: R:3SER S:3SER CONFIRM(ENTER) The important thing to note here is that the number of cells detected by the charger (R) and the number of cells set by you (S) are both 3. If either of these numbers are different immediately power down the charger and contact Student Robotics. Press Start/Enter to commence charging Li3S 2.2A 12.59V BAL 022:43 00682 The screen shows the charging current (here: 2.2A ), the current voltage (here: 12.59V ), the time elapsed (here: 22m43s ) and the energy provided to the battery (here: 682mAh ). The charger will beep when the battery is fully charged. You must then: Unplug the charger from the mains. Unplug the battery from the charging lead, do not unplug the charging lead from the charger with the battery still connected. Unplug the monitoring lead from the battery to the charger.","title":"Charging Checklist"},{"location":"kit/batteries/imax_b6_charger/#troubleshooting","text":"Charger beeps and displays CONNECTION BREAK during charging Either the charging or monitoring lead has come loose. Ensure that both are fully inserted and press the following buttons to resume charging: Batt.Type/Stop \u2192 Start/Enter for 3 seconds \u2192 Start/Enter","title":"Troubleshooting"},{"location":"programming/","text":"Programming Your Robot \u00b6 Robots that are made using the SR kit are programmed with Python which is made possible with a custom-built Python library, sr.robot ; see here for more details. The pages under this section should contain all of the information you need to know to successfully code for your robot. Under the Python section, some of the more intricate features of Python are explained in sufficient detail to program a robot. Links to tutorials are also provided to introduce a new programmer to Python. Under the sr section is an API reference for the Student Robotics module, used to interface with the hardware. This section is purely a reference for writing code, not how to use the IDE, for example, or getting the code onto the robot. For reference material for topics like that, please see the IDE Documentation .","title":"Programming"},{"location":"programming/#programming-your-robot","text":"Robots that are made using the SR kit are programmed with Python which is made possible with a custom-built Python library, sr.robot ; see here for more details. The pages under this section should contain all of the information you need to know to successfully code for your robot. Under the Python section, some of the more intricate features of Python are explained in sufficient detail to program a robot. Links to tutorials are also provided to introduce a new programmer to Python. Under the sr section is an API reference for the Student Robotics module, used to interface with the hardware. This section is purely a reference for writing code, not how to use the IDE, for example, or getting the code onto the robot. For reference material for topics like that, please see the IDE Documentation .","title":"Programming Your Robot"},{"location":"programming/git_repositories/","text":"Git Repositories \u00b6 We strongly recommend that you develop your code within the IDE. However, we appreciate that this can be limiting for some users. Therefore, we provide access to the git repositories that the IDE stores your code in. You can access your git repository by pointing your git client at a URL of the form: https://USERNAME@www.studentrobotics.org/robogit/TEAMTLA/PROJNAME.git Replace: USERNAME with your Student Robotics username. TEAMTLA with the TLA of your team. (You can find this out by logging into the IDE and looking at the team id displayed at the top) PROJNAME with the name of the project that you've already created within the IDE. When you clone the repository, your client will prompt you for your Student Robotics password. When you've done some things, go ahead and push your commits back into the repository. To get your code onto your robot, you will need to use the IDE's export feature as usual. Example \u00b6 If dave from team SRZ has a project called \"armadillo\", then one of their team members might clone it like so: git clone https://dave@www.studentrobotics.org/robogit/SRZ/armadillo.git *[TLA]: Three Letter Acronym","title":"Git Repositories"},{"location":"programming/git_repositories/#git-repositories","text":"We strongly recommend that you develop your code within the IDE. However, we appreciate that this can be limiting for some users. Therefore, we provide access to the git repositories that the IDE stores your code in. You can access your git repository by pointing your git client at a URL of the form: https://USERNAME@www.studentrobotics.org/robogit/TEAMTLA/PROJNAME.git Replace: USERNAME with your Student Robotics username. TEAMTLA with the TLA of your team. (You can find this out by logging into the IDE and looking at the team id displayed at the top) PROJNAME with the name of the project that you've already created within the IDE. When you clone the repository, your client will prompt you for your Student Robotics password. When you've done some things, go ahead and push your commits back into the repository. To get your code onto your robot, you will need to use the IDE's export feature as usual.","title":"Git Repositories"},{"location":"programming/git_repositories/#example","text":"If dave from team SRZ has a project called \"armadillo\", then one of their team members might clone it like so: git clone https://dave@www.studentrobotics.org/robogit/SRZ/armadillo.git *[TLA]: Three Letter Acronym","title":"Example"},{"location":"programming/simulator/","text":"The SR Simulator \u00b6 The SR robot simulator allows you to try out programming ideas with a virtual robot in a virtual arena. The virtual robot has a simple grabber and two motors (configured for skid steering). Its programming interface is very similar to that for your real robot (see the Interface section ). While the simulator's interface attempts to be as realistic as possible, it will not be identical to that of your actual robot. It is therefore highly unlikely that code which works in the simulator will work in the real world without modification. There is no substitute for real-world testing! Installation \u00b6 Follow the instructions for your platform: Windows Linux Mac OS X Windows \u00b6 First, download the Windows ZIP and extract it. In the ZIP you will find a directory called Portable Python , which contains PyScripter-Portable.exe . Double click this to open the PyScripter development environment. Open the file named run.py in the robot-sim folder. This program allows you to launch the simulator. To try it out, run it (by clicking the green play icon on the toolbar, or pressing Ctrl+F9). A dialog box will ask you for a program name. Enter test.py and press ENTER. A test program will run in a simulated arena. (You may need to bring the simulator window to the front by clicking on it in your taskbar.) To create your own program, click File > New. The new file should contain the code you need to get started. Write your code as normal. Save the file in the robot-sim folder on your Desktop. To run your program, run run.py , like you did before. Enter the name of your code file (including the .py ) into the dialog box and press ENTER. Linux \u00b6 First, download the Linux ZIP and extract it. The simulator requires three libraries: pygame , PyPyBox2D , and PyYAML . The easiest way to install these is through your distribution's package manager (although PyPyBox2D is only available through pip ). For example, on Ubuntu, you might run the following commands (the Python development tools are required for pip to install PyPyBox2D): $ sudo apt-get install python-dev python-pip python-pygame python-yaml $ sudo pip install pypybox2d To run a test program, open a terminal in the robot-sim directory from the ZIP and run: $ python run.py test.py To create your own program, write it in a text file using your favourite editor and save it in the robot-sim directory. Run it by replacing test.py in the previous command with the file name. Mac OS X \u00b6 First, download the Mac OS X ZIP and extract it. All files referred to here are in the robot-sim folder from that ZIP. To install the prerequisites for the simulator, run install-macosx.command . You may find that you will need to alter your security settings to allow our software to run on your computer. You can do this in System Preferences in the Security & Privacy section and allow running apps from anywhere. You will also need to make sure that you have Homebrew installed. To run a program in the simulator, run run-macosx.command , and enter the names of the files you wish to run, separated by commas. To test it out, enter test.py and press ENTER. A test program will run in a simulated arena. To create your own program, enter it into a text file and save it in robot-sim . Write your code as normal, and run in the same way. Interface \u00b6 Unless otherwise stated, the simulator's API is the same as the real SR API described in the docs. Motors \u00b6 Motor boards cannot be addressed by serial number. Servos \u00b6 Servos are not supported in the simulator. The Grabber \u00b6 Instead of servos, the robot is equipped with a grabber, capable of picking up a token which is in front of the robot and within 0.4 metres of the robot's centre. To pick up a token, call the R.grab method: success = R . grab () The R.grab method returns True if a token was successfully picked up, or False otherwise. If the robot is already holding a token, it will throw an AlreadyHoldingSomethingException . To drop the token, call the R.release method. Vision \u00b6 To help the robot find tokens and navigate, each token has markers stuck to it, as does each wall. The R.see method returns a list of all the markers the robot can see, as Marker objects. The robot can only see markers which it is facing towards. Each Marker object has the following attributes: info a MarkerInfo object describing the marker itself. Has the following attributes: code the numeric code of the marker. marker_type the type of object the marker is attached to (either MARKER_TOKEN or MARKER_ARENA ). offset offset of the numeric code of the marker from the lowest numbered marker of its type. For example: markers 28 and 29, which are the lowest numbered markers that represent robots, have offsets of 0 and 1 respectively. size the size that the marker would be in the real game (in metres), for compatibility with the SR API. centre the location of the marker in polar coordinates, as a PolarCoord object. Has the following attributes: length the distance from the centre of the robot to the object (in metres). rot_y rotation about the Y axis in degrees. dist an alias for centre.length res the value of the res parameter of R.see , for compatibility with the SR API. rot_y an alias for centre.rot_y timestamp the time at which the marker was seen (when R.see was called). For example, the following code lists all of the markers the robot can see: markers = R . see () print \"I can see\" , len ( markers ), \"markers:\" for m in markers : if m . info . marker_type == MARKER_TOKEN : print \" - Token {0} is {1} metres away\" . format ( m . info . offset , m . dist ) elif m . info . marker_type == MARKER_ARENA : print \" - Arena marker {0} is {1} metres away\" . format ( m . info . offset , m . dist )","title":"Simulator"},{"location":"programming/simulator/#the-sr-simulator","text":"The SR robot simulator allows you to try out programming ideas with a virtual robot in a virtual arena. The virtual robot has a simple grabber and two motors (configured for skid steering). Its programming interface is very similar to that for your real robot (see the Interface section ). While the simulator's interface attempts to be as realistic as possible, it will not be identical to that of your actual robot. It is therefore highly unlikely that code which works in the simulator will work in the real world without modification. There is no substitute for real-world testing!","title":"The SR Simulator"},{"location":"programming/simulator/#installation","text":"Follow the instructions for your platform: Windows Linux Mac OS X","title":"Installation"},{"location":"programming/simulator/#windows","text":"First, download the Windows ZIP and extract it. In the ZIP you will find a directory called Portable Python , which contains PyScripter-Portable.exe . Double click this to open the PyScripter development environment. Open the file named run.py in the robot-sim folder. This program allows you to launch the simulator. To try it out, run it (by clicking the green play icon on the toolbar, or pressing Ctrl+F9). A dialog box will ask you for a program name. Enter test.py and press ENTER. A test program will run in a simulated arena. (You may need to bring the simulator window to the front by clicking on it in your taskbar.) To create your own program, click File > New. The new file should contain the code you need to get started. Write your code as normal. Save the file in the robot-sim folder on your Desktop. To run your program, run run.py , like you did before. Enter the name of your code file (including the .py ) into the dialog box and press ENTER.","title":"Windows"},{"location":"programming/simulator/#linux","text":"First, download the Linux ZIP and extract it. The simulator requires three libraries: pygame , PyPyBox2D , and PyYAML . The easiest way to install these is through your distribution's package manager (although PyPyBox2D is only available through pip ). For example, on Ubuntu, you might run the following commands (the Python development tools are required for pip to install PyPyBox2D): $ sudo apt-get install python-dev python-pip python-pygame python-yaml $ sudo pip install pypybox2d To run a test program, open a terminal in the robot-sim directory from the ZIP and run: $ python run.py test.py To create your own program, write it in a text file using your favourite editor and save it in the robot-sim directory. Run it by replacing test.py in the previous command with the file name.","title":"Linux"},{"location":"programming/simulator/#mac-os-x","text":"First, download the Mac OS X ZIP and extract it. All files referred to here are in the robot-sim folder from that ZIP. To install the prerequisites for the simulator, run install-macosx.command . You may find that you will need to alter your security settings to allow our software to run on your computer. You can do this in System Preferences in the Security & Privacy section and allow running apps from anywhere. You will also need to make sure that you have Homebrew installed. To run a program in the simulator, run run-macosx.command , and enter the names of the files you wish to run, separated by commas. To test it out, enter test.py and press ENTER. A test program will run in a simulated arena. To create your own program, enter it into a text file and save it in robot-sim . Write your code as normal, and run in the same way.","title":"Mac OS X"},{"location":"programming/simulator/#interface","text":"Unless otherwise stated, the simulator's API is the same as the real SR API described in the docs.","title":"Interface"},{"location":"programming/simulator/#motors","text":"Motor boards cannot be addressed by serial number.","title":"Motors"},{"location":"programming/simulator/#servos","text":"Servos are not supported in the simulator.","title":"Servos"},{"location":"programming/simulator/#the-grabber","text":"Instead of servos, the robot is equipped with a grabber, capable of picking up a token which is in front of the robot and within 0.4 metres of the robot's centre. To pick up a token, call the R.grab method: success = R . grab () The R.grab method returns True if a token was successfully picked up, or False otherwise. If the robot is already holding a token, it will throw an AlreadyHoldingSomethingException . To drop the token, call the R.release method.","title":"The Grabber"},{"location":"programming/simulator/#vision","text":"To help the robot find tokens and navigate, each token has markers stuck to it, as does each wall. The R.see method returns a list of all the markers the robot can see, as Marker objects. The robot can only see markers which it is facing towards. Each Marker object has the following attributes: info a MarkerInfo object describing the marker itself. Has the following attributes: code the numeric code of the marker. marker_type the type of object the marker is attached to (either MARKER_TOKEN or MARKER_ARENA ). offset offset of the numeric code of the marker from the lowest numbered marker of its type. For example: markers 28 and 29, which are the lowest numbered markers that represent robots, have offsets of 0 and 1 respectively. size the size that the marker would be in the real game (in metres), for compatibility with the SR API. centre the location of the marker in polar coordinates, as a PolarCoord object. Has the following attributes: length the distance from the centre of the robot to the object (in metres). rot_y rotation about the Y axis in degrees. dist an alias for centre.length res the value of the res parameter of R.see , for compatibility with the SR API. rot_y an alias for centre.rot_y timestamp the time at which the marker was seen (when R.see was called). For example, the following code lists all of the markers the robot can see: markers = R . see () print \"I can see\" , len ( markers ), \"markers:\" for m in markers : if m . info . marker_type == MARKER_TOKEN : print \" - Token {0} is {1} metres away\" . format ( m . info . offset , m . dist ) elif m . info . marker_type == MARKER_ARENA : print \" - Arena marker {0} is {1} metres away\" . format ( m . info . offset , m . dist )","title":"Vision"},{"location":"programming/python/","text":"Python \u00b6 Student Robotics robots are all programmed in Python ; to program a robot, it is important that you have a basic understanding of Python. There are a number of tutorials out there which might help you to learn to program in Python: Our tutorial , called Python: A whirlwind tour . This was written especially for Student Robotics competitors, and explains the basics while trying not to overwhelm you. The Official Tutorial -- the good stuff starts at chapter 3, but you should at least skim the stuff before it; there is a lot there and it may be a little overwhelming. A number of tutorials for beginners are linked to from here . Byte of Python seems like a good one. A number of tutorials for people that have programmed before are linked to from here . Dive Into Python is a good book for people that have programmed before, but it is a fairly long read. The Official Docs , for the version of python on the Odroid Brain Boards . We also host a copy of docs for the precise version (2.7.5) that it uses.","title":"Python"},{"location":"programming/python/#python","text":"Student Robotics robots are all programmed in Python ; to program a robot, it is important that you have a basic understanding of Python. There are a number of tutorials out there which might help you to learn to program in Python: Our tutorial , called Python: A whirlwind tour . This was written especially for Student Robotics competitors, and explains the basics while trying not to overwhelm you. The Official Tutorial -- the good stuff starts at chapter 3, but you should at least skim the stuff before it; there is a lot there and it may be a little overwhelming. A number of tutorials for beginners are linked to from here . Byte of Python seems like a good one. A number of tutorials for people that have programmed before are linked to from here . Dive Into Python is a good book for people that have programmed before, but it is a fairly long read. The Official Docs , for the version of python on the Odroid Brain Boards . We also host a copy of docs for the precise version (2.7.5) that it uses.","title":"Python"},{"location":"programming/python/functions/","text":"Writing your own functions \u00b6 Python allows you to group useful code that you're going to use over and over again into what's called a function . You might want to write a function that handles all the behaviour of your robot once it's got the info back from the vision system, or perhaps something much smaller like a precise left turn. A simple function that calculates the square of a number: def square ( num ): return num ** 2 This would be used by some other code as follows: sq = square ( 5 ) print sq # prints: 25 Another advantage of grouping your code like this is that if you decide you change the way that it works slightly, (but still having it return the same answer) you can do this easily, and the changed code will be used throughout your code, without having to change it in many, many places: The same function modified & printing a log message: def square ( num ): print 'found the square of %d ' % num return num * num","title":"Writing your own functions"},{"location":"programming/python/functions/#writing-your-own-functions","text":"Python allows you to group useful code that you're going to use over and over again into what's called a function . You might want to write a function that handles all the behaviour of your robot once it's got the info back from the vision system, or perhaps something much smaller like a precise left turn. A simple function that calculates the square of a number: def square ( num ): return num ** 2 This would be used by some other code as follows: sq = square ( 5 ) print sq # prints: 25 Another advantage of grouping your code like this is that if you decide you change the way that it works slightly, (but still having it return the same answer) you can do this easily, and the changed code will be used throughout your code, without having to change it in many, many places: The same function modified & printing a log message: def square ( num ): print 'found the square of %d ' % num return num * num","title":"Writing your own functions"},{"location":"programming/python/libraries/","text":"Included Libraries \u00b6 The following python libraries are installed and available for use in your robot's software: Babel 1.3.3 backports 1.0 backports-ssl_match_hostname 3.4.0.2 Blivet 0.23.9 chardet 2.0.1 dateutil 1.5 decorator 3.4.0 di 0.3 flask 0.10.1 hawkey 0.4.18 iniparse 0.4 inotify 0.9.4 IPy 0.75 itsdangerous 0.23 jinja2 2.7.3 Kitchen 1.1.1 libcomps 0.1.6 librepo 1.7.5 markupsafe 0.18 matplotlib 1.3.1 meh 0.27 mglob 0.4 mpmath 0.18 nose 1.3.0 nss 0.15.0 ntplib 0.3.1 numexpr 2.2.2 NumPy 1.8.2 pandas 0.10.0 pexpect 3.1 pillow 2.2.1 [^1] pwquality 1.2.3 pycurl 7.19.3 Pygments 1.6 pygobject2 2.28.6 pygpgme 0.3 pykickstart 1.99.48 [^2] pyliblzma 0.5.3 Pyparsing 2.0.1 PyParted 3.9 pySerial 2.6 pytalloc 2.1.0 pytz 2012d-5 pyudev 0.15 PyUSB 1.0.0 pyxattr 0.5.1 PyXDG 0.25 PyYAML 3.10 SciPy 0.12.1 simplegeneric 0.8 simplejson 3.5.3 six 1.7.3 slip 0.6.0 slip-dbus 0.6.0 sssdconfig 1.11.6 SymPy 0.7.5 tables 3.0.0 Tornado 2.2.1 urlgrabber 3.10.1 Werkzeug 0.9.4 ZeroMQ 13.0.2 [^1]: A maintained fork of PIL [^2]: No relation to our Kickstart event If you wish to use a library that isn't listed above, get in contact with us on the forums and have a chat with us about it.","title":"Included Python Libraries"},{"location":"programming/python/libraries/#included-libraries","text":"The following python libraries are installed and available for use in your robot's software: Babel 1.3.3 backports 1.0 backports-ssl_match_hostname 3.4.0.2 Blivet 0.23.9 chardet 2.0.1 dateutil 1.5 decorator 3.4.0 di 0.3 flask 0.10.1 hawkey 0.4.18 iniparse 0.4 inotify 0.9.4 IPy 0.75 itsdangerous 0.23 jinja2 2.7.3 Kitchen 1.1.1 libcomps 0.1.6 librepo 1.7.5 markupsafe 0.18 matplotlib 1.3.1 meh 0.27 mglob 0.4 mpmath 0.18 nose 1.3.0 nss 0.15.0 ntplib 0.3.1 numexpr 2.2.2 NumPy 1.8.2 pandas 0.10.0 pexpect 3.1 pillow 2.2.1 [^1] pwquality 1.2.3 pycurl 7.19.3 Pygments 1.6 pygobject2 2.28.6 pygpgme 0.3 pykickstart 1.99.48 [^2] pyliblzma 0.5.3 Pyparsing 2.0.1 PyParted 3.9 pySerial 2.6 pytalloc 2.1.0 pytz 2012d-5 pyudev 0.15 PyUSB 1.0.0 pyxattr 0.5.1 PyXDG 0.25 PyYAML 3.10 SciPy 0.12.1 simplegeneric 0.8 simplejson 3.5.3 six 1.7.3 slip 0.6.0 slip-dbus 0.6.0 sssdconfig 1.11.6 SymPy 0.7.5 tables 3.0.0 Tornado 2.2.1 urlgrabber 3.10.1 Werkzeug 0.9.4 ZeroMQ 13.0.2 [^1]: A maintained fork of PIL [^2]: No relation to our Kickstart event If you wish to use a library that isn't listed above, get in contact with us on the forums and have a chat with us about it.","title":"Included Libraries"},{"location":"programming/sr/","text":"SR Module \u00b6 Student Robotics has written a module \u2014 sr.robot \u2014 which is used to interface with the hardware. It handles all the low-level interactions so you don't have to. To set the output power of output 0 of the first motor board to -30%, for example, you would simply write: R . motors [ 0 ] . m0 . power = - 30 -30 would be backwards (depending upon which way you wired up the motor) \u2014 30% power in reverse. To gain access to all of this functionality, all you need to do is write: from sr.robot import * ...at the top of your code (before you use any of its functionality, basically). This imports the Student Robotics module that we've written to interface with our hardware. Then, within the sr.robot module, there is a Robot class that should be instantiated, as follows: from sr.robot import * R = Robot () Within your Robot ( R in this case), you then have access to the following attributes: motors power servos ruggeduinos vision They can be used in your code just like the example above. Note that motors , ruggeduinos , and servos are Python lists, and so should be accessed as such. Here are some examples: R . motors [ 0 ] . m0 . power = 50 # WILL work, if motor 0 exists R . motors [ 1 ] . m0 . power = - 20 # WILL work, if motor 1 exists R . motors . m0 . power = 42 # WON'T WORK # the above is similar to the situation for 'ruggeduinos' and 'servos' A number of examples in the documentation will assume you've instantiated the required Robot class and have called it R . From here in, if you see a R.something , the requirement of the sr.robot import line and the instantiation of Robot as R is implicit. Other Robot Attributes \u00b6 As well as the attributes listed above, the Robot class also has the following attributes, which you may find useful: zone The number of the zone that the robot is associated with. An integer from 0 to 3 inclusive. mode Either \"comp\" or \"dev\". When in a competition match, this will be \"comp\", and at all other times this will be \"dev\". usbkey The path to the USB memory stick. Your code is unzipped and run from a temporary directory, therefore files you create will be lost when the kit is turned off. You can use this to easily read from and write to files on the stick itself. Note that the USB memory stick is mounted synchronously, so any writes to it will block until complete and may slow down your code. An example of how the usbkey attribute might be used: from sr.robot import * import os R = Robot () print \"The path to the USB key is:\" , R . usbkey print \"My file on the USB contains:\" f = open ( os . path . join ( R . usbkey , \"my-file.txt\" ), \"r\" ) print f . read () f . close () Custom Robot Object Initialisation \u00b6 Normally the Robot object is initialised with the following: R = Robot () However if you want to: customise your Ruggeduino firmware initialise some hardware or software before the start button is pressed Then Robot initialisation can be broken up as follows (this example is equivalent to the previous code excerpt): R = Robot . setup () # Setup phase. # Here you can configure hardware enumeration R . init () # Initialisation phase. # Here you can perform hardware/software initialisation before start R . wait_start () During the setup phase, the Robot hardware is inaccessible. For example, R.motors is unavailable since enumerations occurs in the init function. In this phase you can configure how the Robot finds and configures hardware. After the init call, all hardware is accessible. If you have any hardware which must be initialised before the start button is pressed, the initialisation phase is the time to do so.","title":"SR Module"},{"location":"programming/sr/#sr-module","text":"Student Robotics has written a module \u2014 sr.robot \u2014 which is used to interface with the hardware. It handles all the low-level interactions so you don't have to. To set the output power of output 0 of the first motor board to -30%, for example, you would simply write: R . motors [ 0 ] . m0 . power = - 30 -30 would be backwards (depending upon which way you wired up the motor) \u2014 30% power in reverse. To gain access to all of this functionality, all you need to do is write: from sr.robot import * ...at the top of your code (before you use any of its functionality, basically). This imports the Student Robotics module that we've written to interface with our hardware. Then, within the sr.robot module, there is a Robot class that should be instantiated, as follows: from sr.robot import * R = Robot () Within your Robot ( R in this case), you then have access to the following attributes: motors power servos ruggeduinos vision They can be used in your code just like the example above. Note that motors , ruggeduinos , and servos are Python lists, and so should be accessed as such. Here are some examples: R . motors [ 0 ] . m0 . power = 50 # WILL work, if motor 0 exists R . motors [ 1 ] . m0 . power = - 20 # WILL work, if motor 1 exists R . motors . m0 . power = 42 # WON'T WORK # the above is similar to the situation for 'ruggeduinos' and 'servos' A number of examples in the documentation will assume you've instantiated the required Robot class and have called it R . From here in, if you see a R.something , the requirement of the sr.robot import line and the instantiation of Robot as R is implicit.","title":"SR Module"},{"location":"programming/sr/#other-robot-attributes","text":"As well as the attributes listed above, the Robot class also has the following attributes, which you may find useful: zone The number of the zone that the robot is associated with. An integer from 0 to 3 inclusive. mode Either \"comp\" or \"dev\". When in a competition match, this will be \"comp\", and at all other times this will be \"dev\". usbkey The path to the USB memory stick. Your code is unzipped and run from a temporary directory, therefore files you create will be lost when the kit is turned off. You can use this to easily read from and write to files on the stick itself. Note that the USB memory stick is mounted synchronously, so any writes to it will block until complete and may slow down your code. An example of how the usbkey attribute might be used: from sr.robot import * import os R = Robot () print \"The path to the USB key is:\" , R . usbkey print \"My file on the USB contains:\" f = open ( os . path . join ( R . usbkey , \"my-file.txt\" ), \"r\" ) print f . read () f . close ()","title":"Other Robot Attributes"},{"location":"programming/sr/#custom-robot-object-initialisation","text":"Normally the Robot object is initialised with the following: R = Robot () However if you want to: customise your Ruggeduino firmware initialise some hardware or software before the start button is pressed Then Robot initialisation can be broken up as follows (this example is equivalent to the previous code excerpt): R = Robot . setup () # Setup phase. # Here you can configure hardware enumeration R . init () # Initialisation phase. # Here you can perform hardware/software initialisation before start R . wait_start () During the setup phase, the Robot hardware is inaccessible. For example, R.motors is unavailable since enumerations occurs in the init function. In this phase you can configure how the Robot finds and configures hardware. After the init call, all hardware is accessible. If you have any hardware which must be initialised before the start button is pressed, the initialisation phase is the time to do so.","title":"Custom Robot Object Initialisation"},{"location":"programming/sr/motors/","text":"Motors \u00b6 The motors object is used to control a collection of Motor Boards. Similar to ruggeduinos and servos , motors can be used like a list. To do something with the first Motor Board , you would use: R . motors [ 0 ] . something ... ...because indexes are 0-based (counting starts from 0, not 1). When you have more than one Motor Board connected to your kit they will be ordered based upon their SR Part Code, as written on the underside of the board. The SR Part Code of each detected Motor Board is also printed to the log when your robot starts. It will look something like this: Found the following devices: - Motors: 0: Motor( serialnum = \"SR0XJ1F\" ) 1: Motor( serialnum = \"SR0A123\" ) However, like ruggeduinos and servos , motors is actually a dictionary. As a result, in motors you can also use the SR Part Code of the Motor Board as a key. For example, if you had a board that was labelled \"SR0A123\", you could do this instead: R . motors [ \"SR0A123\" ] . something ... Setting motor power \u00b6 Motor power is controlled using PWM with 100% power being a duty cycle of 1. You set the power with an integer value between -100 and 100 inclusive (where a negative value puts the motor in reverse). The field to change the output power is power . As each Motor Board has two outputs you will need to specify which output you want to control: from sr.robot import * import time R = Robot () # motor board 0, channel 0 to full power forward R . motors [ 0 ] . m0 . power = 100 # motor board 1, channel 0 to full power reverse R . motors [ 1 ] . m0 . power = - 100 # motor board 0, channel 1 to half power forward R . motors [ 0 ] . m1 . power = 50 # motor board 1, channel 0 stopped R . motors [ 1 ] . m0 . power = 0 # the following will put motor board 0, channel 1 at 25% power (forwards) for 2.5 seconds: R . motors [ 0 ] . m1 . power = 25 time . sleep ( 2.5 ) # wait for 2.5 seconds R . motors [ 0 ] . m1 . power = 0 You can read the current power value for a motor using the same field: # get the current output power of Motor Board 0, channel 0 currentTarget = R . motors [ 0 ] . m0 . power Stopping the motors \u00b6 When you set the motor power to 0, this signals the Motor Board to actively stop that motor from turning. # store the motor in a local variable because typing it out gets really boring molly = R . motors [ 0 ] . m0 # set the power to 100 for a second, then stop immediately molly . power = 100 time . sleep ( 1 ) molly . power = 0 However, you may also want to allow the motors to gently coast to a halt. This can be achieved by setting the use_brake field of the individual motor. # set braking mode molly . use_brake = False # set the power to 100 for a second, then coast to a stop molly . power = 100 time . sleep ( 1 ) molly . power = 0 # Print the current braking mode (might be handy for debugging!) print ( \"m0.use_brake = {0}\" . format ( molly . use_brake )) The use_brake value defaults to True and, just like the power value, will remain set until you change it.","title":"Motors"},{"location":"programming/sr/motors/#motors","text":"The motors object is used to control a collection of Motor Boards. Similar to ruggeduinos and servos , motors can be used like a list. To do something with the first Motor Board , you would use: R . motors [ 0 ] . something ... ...because indexes are 0-based (counting starts from 0, not 1). When you have more than one Motor Board connected to your kit they will be ordered based upon their SR Part Code, as written on the underside of the board. The SR Part Code of each detected Motor Board is also printed to the log when your robot starts. It will look something like this: Found the following devices: - Motors: 0: Motor( serialnum = \"SR0XJ1F\" ) 1: Motor( serialnum = \"SR0A123\" ) However, like ruggeduinos and servos , motors is actually a dictionary. As a result, in motors you can also use the SR Part Code of the Motor Board as a key. For example, if you had a board that was labelled \"SR0A123\", you could do this instead: R . motors [ \"SR0A123\" ] . something ...","title":"Motors"},{"location":"programming/sr/motors/#setting-motor-power","text":"Motor power is controlled using PWM with 100% power being a duty cycle of 1. You set the power with an integer value between -100 and 100 inclusive (where a negative value puts the motor in reverse). The field to change the output power is power . As each Motor Board has two outputs you will need to specify which output you want to control: from sr.robot import * import time R = Robot () # motor board 0, channel 0 to full power forward R . motors [ 0 ] . m0 . power = 100 # motor board 1, channel 0 to full power reverse R . motors [ 1 ] . m0 . power = - 100 # motor board 0, channel 1 to half power forward R . motors [ 0 ] . m1 . power = 50 # motor board 1, channel 0 stopped R . motors [ 1 ] . m0 . power = 0 # the following will put motor board 0, channel 1 at 25% power (forwards) for 2.5 seconds: R . motors [ 0 ] . m1 . power = 25 time . sleep ( 2.5 ) # wait for 2.5 seconds R . motors [ 0 ] . m1 . power = 0 You can read the current power value for a motor using the same field: # get the current output power of Motor Board 0, channel 0 currentTarget = R . motors [ 0 ] . m0 . power","title":"Setting motor power"},{"location":"programming/sr/motors/#stopping-the-motors","text":"When you set the motor power to 0, this signals the Motor Board to actively stop that motor from turning. # store the motor in a local variable because typing it out gets really boring molly = R . motors [ 0 ] . m0 # set the power to 100 for a second, then stop immediately molly . power = 100 time . sleep ( 1 ) molly . power = 0 However, you may also want to allow the motors to gently coast to a halt. This can be achieved by setting the use_brake field of the individual motor. # set braking mode molly . use_brake = False # set the power to 100 for a second, then coast to a stop molly . power = 100 time . sleep ( 1 ) molly . power = 0 # Print the current braking mode (might be handy for debugging!) print ( \"m0.use_brake = {0}\" . format ( molly . use_brake )) The use_brake value defaults to True and, just like the power value, will remain set until you change it.","title":"Stopping the motors"},{"location":"programming/sr/power/","text":"Power \u00b6 There are a few things that can be done with the power board, namely current and voltage sensing, and beeping. As there is only one power board, it is not accessed like a list like motors for example: R . power . something ... Battery Status \u00b6 The power board can report both the battery voltage, in Volts, and the current being drawn from it, in Amps. You can access these values like so: # Print the battery voltage and current to the log print R . power . battery . voltage , R . power . battery . current A fully charged battery will measure 12.6V. The power board will turn off and signal a low battery at 10.2V. The discharge curve is roughly linear between 11.4V and 10.4V. Power Outputs \u00b6 Each of the power board's six outputs has a constant whose name closely matches the name of the output: H0 : OUT_H0 H1 : OUT_H1 L0 : OUT_L0 L1 : OUT_L1 L2 : OUT_L2 L3 : OUT_L3 While they are all turned on when your code starts running, you can control whether each output is turned on or off like so: # Turn output H0 off R . power . output [ OUT_H0 ] = False # Turn output L0 on R . power . output [ OUT_L0 ] = True An exception is raised if you try to set an output index which doesn't exist. Beeping \u00b6 The power board has a piezo buzzer which can beep. The beep function accepts 1 or 2 parameters, duration is compulsory and is measured in milliseconds. note is optional, but must be one string of a-g or uc . frequency is also optional, and should be an integer. One of note and frequency , must be given. If both are given, note is used. # Beep for 0.5s in D. R . power . beep ( 500 , note = 'd' ) # Beep for 2s at 400Hz R . power . beep ( 2000 , frequency = 400 ) ValueError is raised if the note is not recognised or the frequency is not an integer.","title":"Power"},{"location":"programming/sr/power/#power","text":"There are a few things that can be done with the power board, namely current and voltage sensing, and beeping. As there is only one power board, it is not accessed like a list like motors for example: R . power . something ...","title":"Power"},{"location":"programming/sr/power/#battery-status","text":"The power board can report both the battery voltage, in Volts, and the current being drawn from it, in Amps. You can access these values like so: # Print the battery voltage and current to the log print R . power . battery . voltage , R . power . battery . current A fully charged battery will measure 12.6V. The power board will turn off and signal a low battery at 10.2V. The discharge curve is roughly linear between 11.4V and 10.4V.","title":"Battery Status"},{"location":"programming/sr/power/#power-outputs","text":"Each of the power board's six outputs has a constant whose name closely matches the name of the output: H0 : OUT_H0 H1 : OUT_H1 L0 : OUT_L0 L1 : OUT_L1 L2 : OUT_L2 L3 : OUT_L3 While they are all turned on when your code starts running, you can control whether each output is turned on or off like so: # Turn output H0 off R . power . output [ OUT_H0 ] = False # Turn output L0 on R . power . output [ OUT_L0 ] = True An exception is raised if you try to set an output index which doesn't exist.","title":"Power Outputs"},{"location":"programming/sr/power/#beeping","text":"The power board has a piezo buzzer which can beep. The beep function accepts 1 or 2 parameters, duration is compulsory and is measured in milliseconds. note is optional, but must be one string of a-g or uc . frequency is also optional, and should be an integer. One of note and frequency , must be given. If both are given, note is used. # Beep for 0.5s in D. R . power . beep ( 500 , note = 'd' ) # Beep for 2s at 400Hz R . power . beep ( 2000 , frequency = 400 ) ValueError is raised if the note is not recognised or the frequency is not an integer.","title":"Beeping"},{"location":"programming/sr/servos/","text":"Servos \u00b6 The servos object is used to control a collection of Servo Boards. Similar to motors and ruggeduinos , servos can be used like a list. To do something with the first Servo Board , you would use: R . servos [ 0 ] . something ... ...because indexes are 0-based (counting starts from 0, not 1). When you have more than one Servo Board connected to your kit they will be ordered based upon their serial number. The SR Part Code of each detected motor board is also printed to the log when your robot starts. It will look something like this: Found the following devices: - Servos: 0: Servo( serialnum = \"SR0LG31\" ) However, like motors and ruggeduinos , servos is actually a dictionary. As a result, in servos you can also use the SR Part Code of the Servo Board as a key. For example, if you had a board that was labelled \"SR0LG31\", you could do this instead: R . servos [ \"SR0LG31\" ] . something ... Setting servo positions \u00b6 The position of servos can range from -100 to 100 inclusive: # R.servos[SERVO_BOARD_ID][SERVO_NUMBER] = POS # set servo 1's position (on the first Servo Board connected, board 0) to 20 R . servos [ 0 ][ 1 ] = 20 # Set servo 2's position (on the Servo Board with part code SRABC) to -55 R . servos [ \"SRABC\" ][ 2 ] = - 55 It is important that you use integers (whole numbers, such as `10` instead of `10.0`) when specifying servo positions. You can read the last value a servo was set to using similar code: # get the last setting of the second servo on the first Servo Board lastSetting = R . servos [ 0 ][ 1 ] While it is possible to retrieve the last position a servo was set to, this does not guarantee that the servo is currently in that position. How the set position relates to the servo angle \u00b6 You should be careful about forcing a servo to drive past its end stops. Some servos are very strong and it could damage the internal gears. The angle of an RC servo is controlled by the width of a pulse supplied to it periodically. There is no standard for the width of this pulse and there are differences between manufacturers as to what angle the servo will turn to for a given pulse width. To be able to handle the widest range of all servos our hardware outputs a very wide range of pulse widths which in some cases will force the servo to try and turn past its internal end-stops. You should experiment and find what the actual limit of your servos are (it almost certainly won't be -100 and 100) and not drive them past that.","title":"Servos"},{"location":"programming/sr/servos/#servos","text":"The servos object is used to control a collection of Servo Boards. Similar to motors and ruggeduinos , servos can be used like a list. To do something with the first Servo Board , you would use: R . servos [ 0 ] . something ... ...because indexes are 0-based (counting starts from 0, not 1). When you have more than one Servo Board connected to your kit they will be ordered based upon their serial number. The SR Part Code of each detected motor board is also printed to the log when your robot starts. It will look something like this: Found the following devices: - Servos: 0: Servo( serialnum = \"SR0LG31\" ) However, like motors and ruggeduinos , servos is actually a dictionary. As a result, in servos you can also use the SR Part Code of the Servo Board as a key. For example, if you had a board that was labelled \"SR0LG31\", you could do this instead: R . servos [ \"SR0LG31\" ] . something ...","title":"Servos"},{"location":"programming/sr/servos/#setting-servo-positions","text":"The position of servos can range from -100 to 100 inclusive: # R.servos[SERVO_BOARD_ID][SERVO_NUMBER] = POS # set servo 1's position (on the first Servo Board connected, board 0) to 20 R . servos [ 0 ][ 1 ] = 20 # Set servo 2's position (on the Servo Board with part code SRABC) to -55 R . servos [ \"SRABC\" ][ 2 ] = - 55 It is important that you use integers (whole numbers, such as `10` instead of `10.0`) when specifying servo positions. You can read the last value a servo was set to using similar code: # get the last setting of the second servo on the first Servo Board lastSetting = R . servos [ 0 ][ 1 ] While it is possible to retrieve the last position a servo was set to, this does not guarantee that the servo is currently in that position.","title":"Setting servo positions"},{"location":"programming/sr/servos/#how-the-set-position-relates-to-the-servo-angle","text":"You should be careful about forcing a servo to drive past its end stops. Some servos are very strong and it could damage the internal gears. The angle of an RC servo is controlled by the width of a pulse supplied to it periodically. There is no standard for the width of this pulse and there are differences between manufacturers as to what angle the servo will turn to for a given pulse width. To be able to handle the widest range of all servos our hardware outputs a very wide range of pulse widths which in some cases will force the servo to try and turn past its internal end-stops. You should experiment and find what the actual limit of your servos are (it almost certainly won't be -100 and 100) and not drive them past that.","title":"How the set position relates to the servo angle"},{"location":"programming/sr/ruggeduinos/","text":"IO (Ruggeduino) \u00b6 The Ruggeduino provides a total of 18 pins for either digital input or output (labelled 2 to 13 and A0 to A5), including 6 for analogue input (labelled A0 to A5). The ruggeduinos object is used to control a collection of Ruggeduinos. Similar to motors and servos , ruggeduinos can be used like a list. To do something with the first Ruggeduino , you would use: R . ruggeduinos [ 0 ] . something ... ...because indexes are 0-based (counting starts from 0, not 1). When you have more than one Ruggeduino board connected to your kit they will be ordered based upon their serial number. The serial number of each detected Ruggeduino is printed to the log when your robot starts. It will look something like this: Found the following devices: - Ruggeduinos: 0: Ruggeduino( serialnum = \"752303138333517171B1\" ) In addition, like motors , ruggeduinos is actually a dictionary. As a result, in ruggeduinos you can also use the Ruggeduino serial number as a key. For example, if you had a board whose serial number was \"752303138333517171B1\", you could do this instead: R . ruggeduinos [ \"752303138333517171B1\" ] . something ... Setting pin modes \u00b6 To use one of the pins on the Ruggeduino, you must first set whether you want it to behave as an input or as an output. You can do this with the following code: R . ruggeduinos [ RUGGEDUINO_BOARD_NUMBER ] . pin_mode ( PIN_NO , MODE ) The possible values for MODE are: INPUT set the pin to input mode OUTPUT set the pin to output mode INPUT_PULLUP set the pin to input mode with a pull-up resistor An example of how to use this is below: # set Ruggeduino board 0's pin 2 to output R . ruggeduinos [ 0 ] . pin_mode ( 2 , OUTPUT ) # set Ruggeduino board 0's pin 3 to input R . ruggeduinos [ 0 ] . pin_mode ( 3 , INPUT ) # set Ruggeduino board 0's pin 4 to input and enable pull-up resistor R . ruggeduinos [ 0 ] . pin_mode ( 4 , INPUT_PULLUP ) You cannot use pins 0 and 1, as using these would disrupt communications between the Ruggeduino and the Power Board. Input \u00b6 You can read a digital input pin with the following code: # R.ruggeduinos[RUGGEDUINO_BOARD_NUMBER].digital_read(PIN_NO) # to read Ruggeduino board 0's digital pin 3... pin0 = R . ruggeduinos [ 0 ] . digital_read ( 3 ) pin0 will now contain True or False depending on whether the pin was high (3.3v) or low (0v), respectively. You can read an analogue input pin with the following code: # R.ruggeduinos[RUGGEDUINO_BOARD_NUMBER].analogue_read(PIN_NO) # to read Ruggeduino board 0's analogue pin A0... pin0 = R . ruggeduinos [ 0 ] . analogue_read ( 0 ) Output \u00b6 You can only set digital outputs (there's no analogue output, although you may feel free to modify the Ruggeduino's firmware to add the ability to output PWM if you desire). To set a digital output pin, you would use the following: # R.ruggeduinos[RUGGEDUINO_BOARD_NUMBER].digital_write(PIN_NO, VALUE) # to set Ruggeduino board 0's pin 2 high: R . ruggeduinos [ 0 ] . digital_write ( 2 , True ) # to set Ruggeduino board 0's pin 2 low: R . ruggeduinos [ 0 ] . digital_write ( 2 , False ) Pull-up resistors \u00b6 The Ruggeduino possesses the ability to enable a built-in pull-up resistor on any input pin. This takes a small amount of explanation. Normally, input pins are not connected to anything - known as \"floating\". In this state, they might read high or low, or different values depending on their environment. This is obviously not good for consistent control. Many pieces of off-the-shelf electronics that have some form of standard I/O output will connect this pin to 3.3V (high) and 0V (low) when required, so this is not a problem. However, for simple electronics, a microswitch for example, you would normally be required to connect a resistor between the input pin and 3.3V (a pull-up resistor), or between the input pin and 0V (a pull-down resistor) to keep the input in a known state until the switch overrides it by connecting directly to the opposite state. However, the built-in pull-up resistor alleviates this need. It essentially wires in a resistor connected to 3.3V, meaning that when this option is enabled, an input pin will \"default\" to being high. This means you can simply connect a switch between the input pin and a ground pin without any need of resistors - when the switch is open, the pin will read high; when closed, it will read low.","title":"IO (Ruggeduino)"},{"location":"programming/sr/ruggeduinos/#io-ruggeduino","text":"The Ruggeduino provides a total of 18 pins for either digital input or output (labelled 2 to 13 and A0 to A5), including 6 for analogue input (labelled A0 to A5). The ruggeduinos object is used to control a collection of Ruggeduinos. Similar to motors and servos , ruggeduinos can be used like a list. To do something with the first Ruggeduino , you would use: R . ruggeduinos [ 0 ] . something ... ...because indexes are 0-based (counting starts from 0, not 1). When you have more than one Ruggeduino board connected to your kit they will be ordered based upon their serial number. The serial number of each detected Ruggeduino is printed to the log when your robot starts. It will look something like this: Found the following devices: - Ruggeduinos: 0: Ruggeduino( serialnum = \"752303138333517171B1\" ) In addition, like motors , ruggeduinos is actually a dictionary. As a result, in ruggeduinos you can also use the Ruggeduino serial number as a key. For example, if you had a board whose serial number was \"752303138333517171B1\", you could do this instead: R . ruggeduinos [ \"752303138333517171B1\" ] . something ...","title":"IO (Ruggeduino)"},{"location":"programming/sr/ruggeduinos/#setting-pin-modes","text":"To use one of the pins on the Ruggeduino, you must first set whether you want it to behave as an input or as an output. You can do this with the following code: R . ruggeduinos [ RUGGEDUINO_BOARD_NUMBER ] . pin_mode ( PIN_NO , MODE ) The possible values for MODE are: INPUT set the pin to input mode OUTPUT set the pin to output mode INPUT_PULLUP set the pin to input mode with a pull-up resistor An example of how to use this is below: # set Ruggeduino board 0's pin 2 to output R . ruggeduinos [ 0 ] . pin_mode ( 2 , OUTPUT ) # set Ruggeduino board 0's pin 3 to input R . ruggeduinos [ 0 ] . pin_mode ( 3 , INPUT ) # set Ruggeduino board 0's pin 4 to input and enable pull-up resistor R . ruggeduinos [ 0 ] . pin_mode ( 4 , INPUT_PULLUP ) You cannot use pins 0 and 1, as using these would disrupt communications between the Ruggeduino and the Power Board.","title":"Setting pin modes"},{"location":"programming/sr/ruggeduinos/#input","text":"You can read a digital input pin with the following code: # R.ruggeduinos[RUGGEDUINO_BOARD_NUMBER].digital_read(PIN_NO) # to read Ruggeduino board 0's digital pin 3... pin0 = R . ruggeduinos [ 0 ] . digital_read ( 3 ) pin0 will now contain True or False depending on whether the pin was high (3.3v) or low (0v), respectively. You can read an analogue input pin with the following code: # R.ruggeduinos[RUGGEDUINO_BOARD_NUMBER].analogue_read(PIN_NO) # to read Ruggeduino board 0's analogue pin A0... pin0 = R . ruggeduinos [ 0 ] . analogue_read ( 0 )","title":"Input"},{"location":"programming/sr/ruggeduinos/#output","text":"You can only set digital outputs (there's no analogue output, although you may feel free to modify the Ruggeduino's firmware to add the ability to output PWM if you desire). To set a digital output pin, you would use the following: # R.ruggeduinos[RUGGEDUINO_BOARD_NUMBER].digital_write(PIN_NO, VALUE) # to set Ruggeduino board 0's pin 2 high: R . ruggeduinos [ 0 ] . digital_write ( 2 , True ) # to set Ruggeduino board 0's pin 2 low: R . ruggeduinos [ 0 ] . digital_write ( 2 , False )","title":"Output"},{"location":"programming/sr/ruggeduinos/#pull-up-resistors","text":"The Ruggeduino possesses the ability to enable a built-in pull-up resistor on any input pin. This takes a small amount of explanation. Normally, input pins are not connected to anything - known as \"floating\". In this state, they might read high or low, or different values depending on their environment. This is obviously not good for consistent control. Many pieces of off-the-shelf electronics that have some form of standard I/O output will connect this pin to 3.3V (high) and 0V (low) when required, so this is not a problem. However, for simple electronics, a microswitch for example, you would normally be required to connect a resistor between the input pin and 3.3V (a pull-up resistor), or between the input pin and 0V (a pull-down resistor) to keep the input in a known state until the switch overrides it by connecting directly to the opposite state. However, the built-in pull-up resistor alleviates this need. It essentially wires in a resistor connected to 3.3V, meaning that when this option is enabled, an input pin will \"default\" to being high. This means you can simply connect a switch between the input pin and a ground pin without any need of resistors - when the switch is open, the pin will read high; when closed, it will read low.","title":"Pull-up resistors"},{"location":"programming/sr/ruggeduinos/custom_firmware/","text":"Custom firmware \u00b6 The Ruggeduino that came as part of your kit was shipped with a firmware that provides the functionality outlined in the Ruggeduino page. You may wish to extend the functionality of this firmware, or completely replace it. The sr.robot library provides support for three Ruggeduino firmware scenarios: Default SR firmware Extended SR firmware : Firmwares that add commands to the default SR firmware. Completely custom : Any firmware not derived from the SR firmware. By default, the sr.robot library assumes that all connected Ruggeduinos are running the SR firmware. If you wish to use an extended SR firmware, or completely custom firmware, then you need to tell the Robot object what to do with your Ruggeduino(s). To do this, you will need to expand the initialisation of your Robot object as detailed here . Your code will then look something like this: from sr.robot import * R = Robot . setup () R . init () R . wait_start () # The rest of your code The next step depends on whether you are running an extended SR firmware, or a completely custom firmware. Extension of the SR firmware \u00b6 You may wish to extend the SR firmware with additional functionality. This will allow you to continue using the commands already provided by the SR firmware (e.g. digital_read() ), which means any existing robot code you have won't need modifying very much. When you extend the SR firmware, you'll be adding at least one new command to the firmware. There are almost limitless possibilities of what your commands may do, but here are some examples to give you an idea: Talk to an SPI or I2C sensor. Read N input pins at the same instant in time. Time pulses received from an ultrasound sensor. There are three steps that you will need to go through to implement and use your custom commands: Step 1: Add your command to the Ruggeduino firmware \u00b6 To extend the SR firmware, you will need to first download its source code , and edit it in the Arduino IDE. When the SR ruggeduino python library wants the ruggeduino to run a command, it sends it a single character to tell it which command to run. You'll find a switch statement in the loop() function that processes this command character: switch ( selected_command ) { case 'a' : command_analogue_read (); break ; case 'r' : command_read (); break ; case 'l' : command_write ( LOW ); break ; // ... and so on ... For example, you can see in the above that when it receives an \"a\" character, it calls the command_analogue_read() function. This function does pretty much what it says on the tin: it reads an analogue pin. You will need to add your own entry into this switch statement for your new command. This will need to be represented by a character that doesn't already appear in the switch statement. Let's say you chose \"c\"; your entry would look like this: switch ( selected_command ) { case 'c' : command_bake_cake (); break ; // ... all the original entries ... You would then write your command_bake_cake() function. Your command can read additional data from the serial port if it requires additional information to operate. It can also write a response back to the host (your Python code). Have a look at the command_read() function to see how to do this. Step 2: Extend the Ruggeduino class \u00b6 Your robot's python code will, by default, use a Ruggeduino object to communicate with the Ruggeduino. The object returned to you when you type R.ruggeduinos[0] is a Ruggeduino instance. This object knows how to talk to the default command handlers in the SR firmware. Don't worry if you don't know what \"object\" means -- you can probably blag this without knowing! If you do want to know about them, you'll find introductions to them all over the web. You could try [this one](http://www.jesshamrick.com/2011/05/18/an-introduction-to-classes-and-inheritance-in-python/), for example. You'll need to extend the Ruggeduino class, giving it at least one extra method to perform your command. Start by adding this to your code: from sr.robot import * class CustomisedRuggeduino ( Ruggeduino ): pass You've just declared a class called CustomisedRuggeduino (you will probably want to call it something else that makes more sense in your application). At the moment, it behaves in exactly the same way as the Ruggeduino class. You now need to add your custom method to it: from sr.robot import * class CustomisedRuggeduino ( Ruggeduino ): # Your function for instructing a Ruggeduino to bake a cake def bake_cake ( self ): with self . lock : self . command ( \"c\" ) Skipping ahead for a moment: Once we've told your Robot object about this CustomisedRuggeduino class (which we do in the next step), you will be able to do this: R . ruggeduinos [ 0 ] . bake_cake () # and you'll still be able to do this: R . ruggeduinos [ 0 ] . digital_read ( 3 ) The IDE will unfortunately error about the lack of a `bake_cake` method (or your equivalent) in the above code. This is an expected restriction of the way the IDE checks the syntax of your code. You can therefore ignore these errors (though you should be careful that the error is one of these and not something else). with self.lock: \u00b6 You'll notice that the code above contains a line that reads: with self . lock : Whenever you call self.command , you need to ensure that it is called within a block of code headed by this with statement. This is a tool that makes your code \"thread-safe\". If you're not using threads, then you will still need to use it, but it won't affect the behaviour of your program. Responses \u00b6 The response from your command is returned by the self.command function. Remember that it will be a string, so you will need to convert it as necessary. If, for example, our cake-baking function on our Ruggeduino responds with the number of cakes that were baked, then we could do this: class CustomisedRuggeduino ( Ruggeduino ): def bake_cake ( self ): with self . lock : resp = self . command ( \"c\" ) return int ( resp ) Step 3: Tell the Robot to use your extended class \u00b6 Now that you've extended the Ruggeduino class to create your CustomisedRuggeduino class, it's time to tell the Robot object about it using the ruggeduino_set_handler_by_fwver function: from sr.robot import * # The class that you wrote in step 2 class CustomisedRuggeduino ( Ruggeduino ): def bake_cake ( self ): with self . lock : self . command ( \"c\" ) R = Robot . setup () # Register the custom class with the Robot object R . ruggeduino_set_handler_by_fwver ( \"SRcustom\" , CustomisedRuggeduino ) R . init () R . wait_start () # Now you can call your custom function! R . ruggeduinos [ 0 ] . bake_cake () You're done! You can now use your custom cake-baking firmware! Multiple Ruggeduinos with Extended SR Firmwares \u00b6 You may wish to use multiple Ruggeduinos with your robot, each supporting a different set of commands. There are two ways to go about this. You can change the string \"SRCustom\" in your firmwares to be something different (but make sure you keep the colon that follows it!), and then change the string you pass to ruggeduino_set_handler_by_fwver to suit. For example, if you change it to be \"CakeBaker\" in one of your ruggeduinos, but leave it as \"SRCustom\" in the other, then your enumeration code would become: R . ruggeduino_set_handler_by_fwver ( \"SRcustom\" , CustomisedRuggeduino ) R . ruggeduino_set_handler_by_fwver ( \"CakeBaker\" , CakeBakerRuggeduino ) Alternatively, you can set the handling class using the ID of the Ruggeduino. The Ruggeduino IDs are written to the robot log when you run a program on your robot with your Ruggeduino connected. Instead of using ruggeduino_set_handler_by_fwver , you use ruggeduino_set_handler_by_id : R . ruggeduino_set_handler_by_id ( \"752303138333517171B1\" , CustomisedRuggeduino ) R . ruggeduino_set_handler_by_id ( \"10231028301928310283\" , CakeBakerRuggeduino ) You will then be able to access your ruggeduino using its ID like so: R . ruggeduinos [ \"752303138333517171B1\" ] Completely custom firmware \u00b6 When configured correctly, the Robot object will perform absolutely no serial communications with a completely custom firmware. We refer to this as ignoring a Ruggeduino. To configure a Robot object to ignore a Ruggeduino with custom firmware, you will need to provide it with the Ruggeduino's ID. The Ruggeduino ID is a 20 character string of mostly numbers, and is output in the robot log when you run a program on your robot with your Ruggeduino connected. After calling Robot.setup() , you should call the ruggeduino_ignore_id method of the robot object, with the ID as an argument. You'll need the ID later, so it's best to save it into a variable: from sr.robot import * RUGGEDUINO_ID = \"752303138333517171B1\" # Replace this with the actual ID R = Robot . setup () R . ruggeduino_ignore_id ( RUGGEDUINO_ID ) R . init () R . wait_start () # The rest of your code If you need to communicate with the Ruggeduino firmware, you will need its serial device path. This is accessible after the R.init() call through the list of Ruggeduinos: # ... Robot.setup() ... etc. R . init () ruggeduino_device = R . ruggeduinos [ RUGGEDUINO_ID ] . path # Do your Ruggeduino initialisation here if you wish R . wait_start () # The rest of your code You may wish to use pyserial to communicate with the Ruggeduino, in which case you could open it like so: import serial from sr.robot import * RUGGEDUINO_ID = \"752303138333517171B1\" R = Robot . setup () R . ruggeduino_ignore_id ( RUGGEDUINO_ID ) R . init () R . wait_start () ser = serial . Serial ( R . ruggeduinos [ RUGGEDUINO_ID ] . path ) Refer to the pyserial documentation for more information on how to use pyserial.","title":"Ruggeduino custom firmware"},{"location":"programming/sr/ruggeduinos/custom_firmware/#custom-firmware","text":"The Ruggeduino that came as part of your kit was shipped with a firmware that provides the functionality outlined in the Ruggeduino page. You may wish to extend the functionality of this firmware, or completely replace it. The sr.robot library provides support for three Ruggeduino firmware scenarios: Default SR firmware Extended SR firmware : Firmwares that add commands to the default SR firmware. Completely custom : Any firmware not derived from the SR firmware. By default, the sr.robot library assumes that all connected Ruggeduinos are running the SR firmware. If you wish to use an extended SR firmware, or completely custom firmware, then you need to tell the Robot object what to do with your Ruggeduino(s). To do this, you will need to expand the initialisation of your Robot object as detailed here . Your code will then look something like this: from sr.robot import * R = Robot . setup () R . init () R . wait_start () # The rest of your code The next step depends on whether you are running an extended SR firmware, or a completely custom firmware.","title":"Custom firmware"},{"location":"programming/sr/ruggeduinos/custom_firmware/#extension-of-the-sr-firmware","text":"You may wish to extend the SR firmware with additional functionality. This will allow you to continue using the commands already provided by the SR firmware (e.g. digital_read() ), which means any existing robot code you have won't need modifying very much. When you extend the SR firmware, you'll be adding at least one new command to the firmware. There are almost limitless possibilities of what your commands may do, but here are some examples to give you an idea: Talk to an SPI or I2C sensor. Read N input pins at the same instant in time. Time pulses received from an ultrasound sensor. There are three steps that you will need to go through to implement and use your custom commands:","title":"Extension of the SR firmware"},{"location":"programming/sr/ruggeduinos/custom_firmware/#step-1-add-your-command-to-the-ruggeduino-firmware","text":"To extend the SR firmware, you will need to first download its source code , and edit it in the Arduino IDE. When the SR ruggeduino python library wants the ruggeduino to run a command, it sends it a single character to tell it which command to run. You'll find a switch statement in the loop() function that processes this command character: switch ( selected_command ) { case 'a' : command_analogue_read (); break ; case 'r' : command_read (); break ; case 'l' : command_write ( LOW ); break ; // ... and so on ... For example, you can see in the above that when it receives an \"a\" character, it calls the command_analogue_read() function. This function does pretty much what it says on the tin: it reads an analogue pin. You will need to add your own entry into this switch statement for your new command. This will need to be represented by a character that doesn't already appear in the switch statement. Let's say you chose \"c\"; your entry would look like this: switch ( selected_command ) { case 'c' : command_bake_cake (); break ; // ... all the original entries ... You would then write your command_bake_cake() function. Your command can read additional data from the serial port if it requires additional information to operate. It can also write a response back to the host (your Python code). Have a look at the command_read() function to see how to do this.","title":"Step 1: Add your command to the Ruggeduino firmware"},{"location":"programming/sr/ruggeduinos/custom_firmware/#step-2-extend-the-ruggeduino-class","text":"Your robot's python code will, by default, use a Ruggeduino object to communicate with the Ruggeduino. The object returned to you when you type R.ruggeduinos[0] is a Ruggeduino instance. This object knows how to talk to the default command handlers in the SR firmware. Don't worry if you don't know what \"object\" means -- you can probably blag this without knowing! If you do want to know about them, you'll find introductions to them all over the web. You could try [this one](http://www.jesshamrick.com/2011/05/18/an-introduction-to-classes-and-inheritance-in-python/), for example. You'll need to extend the Ruggeduino class, giving it at least one extra method to perform your command. Start by adding this to your code: from sr.robot import * class CustomisedRuggeduino ( Ruggeduino ): pass You've just declared a class called CustomisedRuggeduino (you will probably want to call it something else that makes more sense in your application). At the moment, it behaves in exactly the same way as the Ruggeduino class. You now need to add your custom method to it: from sr.robot import * class CustomisedRuggeduino ( Ruggeduino ): # Your function for instructing a Ruggeduino to bake a cake def bake_cake ( self ): with self . lock : self . command ( \"c\" ) Skipping ahead for a moment: Once we've told your Robot object about this CustomisedRuggeduino class (which we do in the next step), you will be able to do this: R . ruggeduinos [ 0 ] . bake_cake () # and you'll still be able to do this: R . ruggeduinos [ 0 ] . digital_read ( 3 ) The IDE will unfortunately error about the lack of a `bake_cake` method (or your equivalent) in the above code. This is an expected restriction of the way the IDE checks the syntax of your code. You can therefore ignore these errors (though you should be careful that the error is one of these and not something else).","title":"Step 2: Extend the Ruggeduino class"},{"location":"programming/sr/ruggeduinos/custom_firmware/#with-selflock","text":"You'll notice that the code above contains a line that reads: with self . lock : Whenever you call self.command , you need to ensure that it is called within a block of code headed by this with statement. This is a tool that makes your code \"thread-safe\". If you're not using threads, then you will still need to use it, but it won't affect the behaviour of your program.","title":"with self.lock:"},{"location":"programming/sr/ruggeduinos/custom_firmware/#responses","text":"The response from your command is returned by the self.command function. Remember that it will be a string, so you will need to convert it as necessary. If, for example, our cake-baking function on our Ruggeduino responds with the number of cakes that were baked, then we could do this: class CustomisedRuggeduino ( Ruggeduino ): def bake_cake ( self ): with self . lock : resp = self . command ( \"c\" ) return int ( resp )","title":"Responses"},{"location":"programming/sr/ruggeduinos/custom_firmware/#step-3-tell-the-robot-to-use-your-extended-class","text":"Now that you've extended the Ruggeduino class to create your CustomisedRuggeduino class, it's time to tell the Robot object about it using the ruggeduino_set_handler_by_fwver function: from sr.robot import * # The class that you wrote in step 2 class CustomisedRuggeduino ( Ruggeduino ): def bake_cake ( self ): with self . lock : self . command ( \"c\" ) R = Robot . setup () # Register the custom class with the Robot object R . ruggeduino_set_handler_by_fwver ( \"SRcustom\" , CustomisedRuggeduino ) R . init () R . wait_start () # Now you can call your custom function! R . ruggeduinos [ 0 ] . bake_cake () You're done! You can now use your custom cake-baking firmware!","title":"Step 3: Tell the Robot to use your extended class"},{"location":"programming/sr/ruggeduinos/custom_firmware/#multiple-ruggeduinos-with-extended-sr-firmwares","text":"You may wish to use multiple Ruggeduinos with your robot, each supporting a different set of commands. There are two ways to go about this. You can change the string \"SRCustom\" in your firmwares to be something different (but make sure you keep the colon that follows it!), and then change the string you pass to ruggeduino_set_handler_by_fwver to suit. For example, if you change it to be \"CakeBaker\" in one of your ruggeduinos, but leave it as \"SRCustom\" in the other, then your enumeration code would become: R . ruggeduino_set_handler_by_fwver ( \"SRcustom\" , CustomisedRuggeduino ) R . ruggeduino_set_handler_by_fwver ( \"CakeBaker\" , CakeBakerRuggeduino ) Alternatively, you can set the handling class using the ID of the Ruggeduino. The Ruggeduino IDs are written to the robot log when you run a program on your robot with your Ruggeduino connected. Instead of using ruggeduino_set_handler_by_fwver , you use ruggeduino_set_handler_by_id : R . ruggeduino_set_handler_by_id ( \"752303138333517171B1\" , CustomisedRuggeduino ) R . ruggeduino_set_handler_by_id ( \"10231028301928310283\" , CakeBakerRuggeduino ) You will then be able to access your ruggeduino using its ID like so: R . ruggeduinos [ \"752303138333517171B1\" ]","title":"Multiple Ruggeduinos with Extended SR Firmwares"},{"location":"programming/sr/ruggeduinos/custom_firmware/#completely-custom-firmware","text":"When configured correctly, the Robot object will perform absolutely no serial communications with a completely custom firmware. We refer to this as ignoring a Ruggeduino. To configure a Robot object to ignore a Ruggeduino with custom firmware, you will need to provide it with the Ruggeduino's ID. The Ruggeduino ID is a 20 character string of mostly numbers, and is output in the robot log when you run a program on your robot with your Ruggeduino connected. After calling Robot.setup() , you should call the ruggeduino_ignore_id method of the robot object, with the ID as an argument. You'll need the ID later, so it's best to save it into a variable: from sr.robot import * RUGGEDUINO_ID = \"752303138333517171B1\" # Replace this with the actual ID R = Robot . setup () R . ruggeduino_ignore_id ( RUGGEDUINO_ID ) R . init () R . wait_start () # The rest of your code If you need to communicate with the Ruggeduino firmware, you will need its serial device path. This is accessible after the R.init() call through the list of Ruggeduinos: # ... Robot.setup() ... etc. R . init () ruggeduino_device = R . ruggeduinos [ RUGGEDUINO_ID ] . path # Do your Ruggeduino initialisation here if you wish R . wait_start () # The rest of your code You may wish to use pyserial to communicate with the Ruggeduino, in which case you could open it like so: import serial from sr.robot import * RUGGEDUINO_ID = \"752303138333517171B1\" R = Robot . setup () R . ruggeduino_ignore_id ( RUGGEDUINO_ID ) R . init () R . wait_start () ser = serial . Serial ( R . ruggeduinos [ RUGGEDUINO_ID ] . path ) Refer to the pyserial documentation for more information on how to use pyserial.","title":"Completely custom firmware"},{"location":"programming/sr/vision/","text":"Vision \u00b6 The sr.robot library contains support for detecting libkoki markers with the provided webcam. Markers are attached to various items in the Student Robotics arena. Each marker encodes a number in a machine-readable way, which means that robots can identify these objects. For information on which markers codes are which, see the markers page . Using knowledge of the physical size of the different markers and the characteristics of the webcam, libkoki can calculate the position of markers in 3D space relative to the camera. Therefore, if the robot can see a marker that is at a fixed location in the arena, a robot can calculate its exact position in the arena. The sr.robot library provides all of this power through a single function, R.see : from sr.robot import * R = Robot () markers = R . see () When called, this function takes a photo through the webcam and searches for markers within it. It returns a list of Marker objects, each of which describes one of the markers that were found in the image. A detailed description of the attributes of Marker objects is provided later in this page . Here's an example that will repeatedly print out the distance to each arena marker that the robot can see: from sr.robot import * R = Robot () while True : markers = R . see () print \"I can see\" , len ( markers ), \"markers:\" for m in markers : if m . info . marker_type == MARKER_ARENA : print \" - Marker #{0} is {1} metres away\" . format ( m . info . code , m . dist ) Choosing Resolution \u00b6 By default, the R.see function will take a photo at a resolution of 800x600. The resolution that this image is taken at can be changed using the optional res argument: # Take a photo at 1280 x 1024 markers = R . see ( res = ( 1280 , 1024 ) ) There are currently two kinds of webcam issued with SR kit: the Logitech C500 and C270. They support the following resolutions: Resolution C500 C270 160 x 120 yes yes 176 x 144 yes yes 320 x 176 yes 320 x 240 yes yes 352 x 288 yes yes 432 x 240 yes 544 x 288 yes 640 x 360 yes 640 x 400 yes 640 x 480 yes yes 752 x 416 yes 800 x 448 yes 800 x 600 (Default) yes yes 864 x 480 yes 960 x 544 yes 960 x 720 yes yes 1024 x 576 yes 1280 x 720 yes yes 1280 x 800 yes 1280 x 960 yes 1280 x 1024 yes There are advantages and disadvantages to switching resolution. Smaller images will process faster, but markers will be less likely to be detected within them. Additionally, the act of changing resolution takes a significant amount of time. The optimum resolution to use in a given situation is best determined through experiment. The Logitech C500 has a field of view of 72\u00b0 and the C270 has a field of view of 60\u00b0. Definition of Axes \u00b6 The vision system describes the markers it can see using three coordinate systems. These are intended to be complementary to each other and contain the same information in different forms. The individual coordinate systems used are detailed below on the Point object, which represents a point in space. Both it and the Orientation object provide further details about what measurements of rotation or position mean for their attributes. The axis definitions match those in common use, as follows: x-axis The horizontal axis running left-to-right in front of the camera. Rotation about this axis is equivalent to leaning towards or away from the camera. y-axis The vertical axis running top-to-bottom in front of the camera. Rotation about this axis is equivalent to turning on the spot, to the left or right. z-axis The axis leading away from the camera to infinity. Rotation about this axis is equivalent to being rolled sideways. Note that the axes are all defined relative to the camera. Since we have no way to know how you've mounted your camera, you may need to account for that in your usage of the vision system's data. Objects of the Vision System \u00b6 Marker \u00b6 A Marker object contains information about a detected marker. It has the following attributes: info A MarkerInfo object containing information about the type of marker that was detected. centre A Point describing the position of the centre of the marker. vertices A list of 4 Point instances, each representing the position of the black corners of the marker. dist An alias for centre.polar.length rot_y An alias for centre.polar.rot_y orientation An Orientation instance describing the orientation of the marker. res The resolution of the image that was taken from the webcam. A 2-item tuple: (width, height). timestamp The timestamp at which the image was taken (a float). MarkerInfo \u00b6 The MarkerInfo object contains information about a marker. It has the following attributes: code The numeric code of the marker. marker_type The type of object that this marker represents. One of: MARKER_ARENA (other marker types based on this year's game will be documented soon) offset The offset of the numeric code of the marker from the lowest numbered marker of its type. For example: markers 28 and 29, which are the lowest numbered markers that represent robots, have offsets of 0 and 1 respectively. size The size of the marker in metres. This is the length of the side of the main black body of the marker. Point \u00b6 A Point object describes a position in three different ways. These are accessed through the following attributes: image The pixel coordinates of the point in the image, with the origin (0,0) in the top-left of the image. This has two attributes: x and y . world The Cartesian coordinates of the point in 3D space. This has three attributes: x , y , and z , each of which specifies a distance in metres. Positions in front of, to the right, or above the camera are positive. Positions to the left or below are negative. polar The polar coordinates of the point in 3D space. This has three attributes: length The distance to the point. rot_x Rotation about the x-axis in degrees. Positions above the camera are positive. rot_y Rotation about the y-axis in degrees. Positions to the right of the camera are positive. For example, the following code displays the polar coordinate of a Point object p : print \"length\" , p . polar . length print \"rot_x\" , p . polar . rot_x print \"rot_y\" , p . polar . rot_y Orientation \u00b6 An Orientation object describes the orientation of a marker. It has three attributes: rot_x Rotation of the marker about the x-axis. Leaning a marker away from the camera increases the value of rot_x , while leaning it towards the camera decreases it. A value of 0 indicates that the marker is upright. rot_y Rotation of the marker about the y-axis. Turning a marker clockwise (as viewed from above) increases the value of rot_y , while turning it anticlockwise decreases it. A value of 0 means that the marker is perpendicular to the line of sight of the camera. rot_z Rotation of the marker about the z-axis. Turning a marker anticlockwise (as viewed from the camera) increases the value of rot_z , while turning it clockwise decreases it. A value of 0 indicates that the marker is upright.","title":"Vision"},{"location":"programming/sr/vision/#vision","text":"The sr.robot library contains support for detecting libkoki markers with the provided webcam. Markers are attached to various items in the Student Robotics arena. Each marker encodes a number in a machine-readable way, which means that robots can identify these objects. For information on which markers codes are which, see the markers page . Using knowledge of the physical size of the different markers and the characteristics of the webcam, libkoki can calculate the position of markers in 3D space relative to the camera. Therefore, if the robot can see a marker that is at a fixed location in the arena, a robot can calculate its exact position in the arena. The sr.robot library provides all of this power through a single function, R.see : from sr.robot import * R = Robot () markers = R . see () When called, this function takes a photo through the webcam and searches for markers within it. It returns a list of Marker objects, each of which describes one of the markers that were found in the image. A detailed description of the attributes of Marker objects is provided later in this page . Here's an example that will repeatedly print out the distance to each arena marker that the robot can see: from sr.robot import * R = Robot () while True : markers = R . see () print \"I can see\" , len ( markers ), \"markers:\" for m in markers : if m . info . marker_type == MARKER_ARENA : print \" - Marker #{0} is {1} metres away\" . format ( m . info . code , m . dist )","title":"Vision"},{"location":"programming/sr/vision/#choosing-resolution","text":"By default, the R.see function will take a photo at a resolution of 800x600. The resolution that this image is taken at can be changed using the optional res argument: # Take a photo at 1280 x 1024 markers = R . see ( res = ( 1280 , 1024 ) ) There are currently two kinds of webcam issued with SR kit: the Logitech C500 and C270. They support the following resolutions: Resolution C500 C270 160 x 120 yes yes 176 x 144 yes yes 320 x 176 yes 320 x 240 yes yes 352 x 288 yes yes 432 x 240 yes 544 x 288 yes 640 x 360 yes 640 x 400 yes 640 x 480 yes yes 752 x 416 yes 800 x 448 yes 800 x 600 (Default) yes yes 864 x 480 yes 960 x 544 yes 960 x 720 yes yes 1024 x 576 yes 1280 x 720 yes yes 1280 x 800 yes 1280 x 960 yes 1280 x 1024 yes There are advantages and disadvantages to switching resolution. Smaller images will process faster, but markers will be less likely to be detected within them. Additionally, the act of changing resolution takes a significant amount of time. The optimum resolution to use in a given situation is best determined through experiment. The Logitech C500 has a field of view of 72\u00b0 and the C270 has a field of view of 60\u00b0.","title":"Choosing Resolution"},{"location":"programming/sr/vision/#definition-of-axes","text":"The vision system describes the markers it can see using three coordinate systems. These are intended to be complementary to each other and contain the same information in different forms. The individual coordinate systems used are detailed below on the Point object, which represents a point in space. Both it and the Orientation object provide further details about what measurements of rotation or position mean for their attributes. The axis definitions match those in common use, as follows: x-axis The horizontal axis running left-to-right in front of the camera. Rotation about this axis is equivalent to leaning towards or away from the camera. y-axis The vertical axis running top-to-bottom in front of the camera. Rotation about this axis is equivalent to turning on the spot, to the left or right. z-axis The axis leading away from the camera to infinity. Rotation about this axis is equivalent to being rolled sideways. Note that the axes are all defined relative to the camera. Since we have no way to know how you've mounted your camera, you may need to account for that in your usage of the vision system's data.","title":"Definition of Axes"},{"location":"programming/sr/vision/#objects-of-the-vision-system","text":"","title":"Objects of the Vision System"},{"location":"programming/sr/vision/#marker","text":"A Marker object contains information about a detected marker. It has the following attributes: info A MarkerInfo object containing information about the type of marker that was detected. centre A Point describing the position of the centre of the marker. vertices A list of 4 Point instances, each representing the position of the black corners of the marker. dist An alias for centre.polar.length rot_y An alias for centre.polar.rot_y orientation An Orientation instance describing the orientation of the marker. res The resolution of the image that was taken from the webcam. A 2-item tuple: (width, height). timestamp The timestamp at which the image was taken (a float).","title":"Marker"},{"location":"programming/sr/vision/#markerinfo","text":"The MarkerInfo object contains information about a marker. It has the following attributes: code The numeric code of the marker. marker_type The type of object that this marker represents. One of: MARKER_ARENA (other marker types based on this year's game will be documented soon) offset The offset of the numeric code of the marker from the lowest numbered marker of its type. For example: markers 28 and 29, which are the lowest numbered markers that represent robots, have offsets of 0 and 1 respectively. size The size of the marker in metres. This is the length of the side of the main black body of the marker.","title":"MarkerInfo"},{"location":"programming/sr/vision/#point","text":"A Point object describes a position in three different ways. These are accessed through the following attributes: image The pixel coordinates of the point in the image, with the origin (0,0) in the top-left of the image. This has two attributes: x and y . world The Cartesian coordinates of the point in 3D space. This has three attributes: x , y , and z , each of which specifies a distance in metres. Positions in front of, to the right, or above the camera are positive. Positions to the left or below are negative. polar The polar coordinates of the point in 3D space. This has three attributes: length The distance to the point. rot_x Rotation about the x-axis in degrees. Positions above the camera are positive. rot_y Rotation about the y-axis in degrees. Positions to the right of the camera are positive. For example, the following code displays the polar coordinate of a Point object p : print \"length\" , p . polar . length print \"rot_x\" , p . polar . rot_x print \"rot_y\" , p . polar . rot_y","title":"Point"},{"location":"programming/sr/vision/#orientation","text":"An Orientation object describes the orientation of a marker. It has three attributes: rot_x Rotation of the marker about the x-axis. Leaning a marker away from the camera increases the value of rot_x , while leaning it towards the camera decreases it. A value of 0 indicates that the marker is upright. rot_y Rotation of the marker about the y-axis. Turning a marker clockwise (as viewed from above) increases the value of rot_y , while turning it anticlockwise decreases it. A value of 0 means that the marker is perpendicular to the line of sight of the camera. rot_z Rotation of the marker about the z-axis. Turning a marker anticlockwise (as viewed from the camera) increases the value of rot_z , while turning it clockwise decreases it. A value of 0 indicates that the marker is upright.","title":"Orientation"},{"location":"programming/sr/vision/markers/","text":"Markers \u00b6 An example libkoki marker is given to the right; this one is arena-0 . There is a dot in the top-left corner of the black border. This corner is known as the principal corner , and its location is important if measuring the marker's orientation about the Z-axis. There is also some text in the bottom-left corner of the black border. This text will say something like \"libkoki marker #0 (v0.5) 'ARENA'\" . Let's break that down: #0 means marker number 0; (v0.5) tells you the version of the marker, it is important the latest version is used; and 'ARENA' is just a human-readable description of what the marker is for. Details of the types and size of markers used in this year's game will be available in the rules , when they are published. The Arena and Token markers, due to their size, need to be printed on A3 paper. You must ensure that your PDF viewer is not resizing the documents when printing. This can be checked by measuring the grey box around the marker and comparing this to the size defined in the rules. If the printed marker is not the correct size then the distance information reported by the vision API will be wrong. Note that a different set of markers will be used in the arenas at the competition. However, this is not something you need to worry about. We will handle this for you automatically when your robot is started in competition mode. The white space around the markers is very important -- without it, the markers probably won't be recognised. If the markers become damaged (scuff markers, tears, etc...) they will not function as well (if at all). If this happens, it is best to just print another one.","title":"Markers"},{"location":"programming/sr/vision/markers/#markers","text":"An example libkoki marker is given to the right; this one is arena-0 . There is a dot in the top-left corner of the black border. This corner is known as the principal corner , and its location is important if measuring the marker's orientation about the Z-axis. There is also some text in the bottom-left corner of the black border. This text will say something like \"libkoki marker #0 (v0.5) 'ARENA'\" . Let's break that down: #0 means marker number 0; (v0.5) tells you the version of the marker, it is important the latest version is used; and 'ARENA' is just a human-readable description of what the marker is for. Details of the types and size of markers used in this year's game will be available in the rules , when they are published. The Arena and Token markers, due to their size, need to be printed on A3 paper. You must ensure that your PDF viewer is not resizing the documents when printing. This can be checked by measuring the grey box around the marker and comparing this to the size defined in the rules. If the printed marker is not the correct size then the distance information reported by the vision API will be wrong. Note that a different set of markers will be used in the arenas at the competition. However, this is not something you need to worry about. We will handle this for you automatically when your robot is started in competition mode. The white space around the markers is very important -- without it, the markers probably won't be recognised. If the markers become damaged (scuff markers, tears, etc...) they will not function as well (if at all). If this happens, it is best to just print another one.","title":"Markers"},{"location":"rules/","text":"2019 Rules \u00b6 The rules, regulations and specifications for the SR2019 competition can be found in the rulebook . The PDF may be subject to minor changes, so please ensure you're using the most up-to-date version. We will also let you know of any important changes by email.","title":"2019 Rules"},{"location":"rules/#2019-rules","text":"The rules, regulations and specifications for the SR2019 competition can be found in the rulebook . The PDF may be subject to minor changes, so please ensure you're using the most up-to-date version. We will also let you know of any important changes by email.","title":"2019 Rules"},{"location":"team_admin/","text":"Team Admin \u00b6 The pages in this section cover all of the non-competition related topics, such as user management and kit shipping .","title":"Team Admin"},{"location":"team_admin/#team-admin","text":"The pages in this section cover all of the non-competition related topics, such as user management and kit shipping .","title":"Team Admin"},{"location":"team_admin/kit_shipping/","text":"Kit Shipping \u00b6 This page provides details of how to ship a Student Robotics kit. Please only ship a Student Robotics kit if instructed to do so by the Kit Logistics Coordinator . If you have a kit that you need to ship to us please follow the instructions in the Packaging section. Once you have your kit packaged, or are looking to get a kit collected from us to be delivered to you, please follow the instructions in the Arranging a Courier section. Packaging \u00b6 When shipping a complete kit to us it should be shipped in the white 18l Really Useful Box it was provided in. We will supply you with a return shipping pack that includes the materials necessary to safely seal up the box. Inside the box, all parts of the kit should either be placed into the jiffy bags that they were provided in (if you still have them) or wrapped in bubble wrap. The batteries must be placed inside the charging bag provided with the kit. If you suspect that any batteries are damaged then do not ship them and contact logistics@studentrobotics.org immediately. Any remaining space in the box should be filled either with paper packaging (old Amazon parcels are a good source of this) or bubble wrap. Please do not use packing peanuts as these are messy and hard to dispose of. Once all of the parts of the kit are safely packed into the Really Useful Box please follow the instructions provided with the return shipping pack to seal up the box. Arranging a Courier \u00b6 Arranging for a courier to collect the kit/package and deliver it can be done quickly and easily through multiple websites. The steps below outline how this is done. For the couriers listed, they will come and collect the package from the collection address you specify. Since the kits contain lithium polymer batteries there are some restrictions around shipping. We have confirmed that the couriers listed below are happy with shipping packages containing the size and quantity of batteries provided in the kit. Step-by-step instructions for more couriers will be added to this page in due course. Kit Details \u00b6 Dimensions: 48cm x 39cm x 20cm Weight: 6kg Value (for insurance): \u00a3500 Batteries: Lithium Ion. Packed with equipment. Batteries less than 100Wh. In all circumstances a shipment of a kit must have at least \u00a3500 worth of insurance. Interlink \u00b6 Go to http://www.interlinkdirect.co.uk/ . Fill in the delivery and collection postcodes in the 'Quote/Send A Parcel' section, enter your email address and click 'Send A Parcel Within UK'. Enter the dimensions and weight from the Kit Details section and click next. Select the 'Next Day' service and 'Collection Tomorrow or later' (please do not select 'Collect Today' if you are arranging for a kit to be collected from us as we need time to prepare for the courier). Choose '\u00a3500' from the 'Extended Liability Cover' drop-down and click next. Enter the collection address. If you are arranging for a kit to be collected from us then please use the address you have been given by the Kit Logistics Coordinator. Also, if you are arranging for collection from us, please chose a collection date a couple of days in the future. Click next. Enter the delivery address. If you are arranging for a kit to be sent to us then please use the address you have been given by the Kit Logistics Coordinator. Set the 'Description of Contents' to 'Other' and enter 'Robotics kit' in the 'Description (if other)' field. Click next. Follow the instructions on the remaining pages to pay. Please double check all of the information on the 'Shipping Confirmation' page before paying. You will now receive a shipping label. If you are arranging for a kit to be collected from us then please email this to logistics@studentrobotics.org immediately. If you are sending a kit to us, please attach the shipping label to the package. If you're getting the package collected from a school, please ensure that you leave it with the reception desk and that they are aware it is being collected.","title":"Kit Shipping"},{"location":"team_admin/kit_shipping/#kit-shipping","text":"This page provides details of how to ship a Student Robotics kit. Please only ship a Student Robotics kit if instructed to do so by the Kit Logistics Coordinator . If you have a kit that you need to ship to us please follow the instructions in the Packaging section. Once you have your kit packaged, or are looking to get a kit collected from us to be delivered to you, please follow the instructions in the Arranging a Courier section.","title":"Kit Shipping"},{"location":"team_admin/kit_shipping/#packaging","text":"When shipping a complete kit to us it should be shipped in the white 18l Really Useful Box it was provided in. We will supply you with a return shipping pack that includes the materials necessary to safely seal up the box. Inside the box, all parts of the kit should either be placed into the jiffy bags that they were provided in (if you still have them) or wrapped in bubble wrap. The batteries must be placed inside the charging bag provided with the kit. If you suspect that any batteries are damaged then do not ship them and contact logistics@studentrobotics.org immediately. Any remaining space in the box should be filled either with paper packaging (old Amazon parcels are a good source of this) or bubble wrap. Please do not use packing peanuts as these are messy and hard to dispose of. Once all of the parts of the kit are safely packed into the Really Useful Box please follow the instructions provided with the return shipping pack to seal up the box.","title":"Packaging"},{"location":"team_admin/kit_shipping/#arranging-a-courier","text":"Arranging for a courier to collect the kit/package and deliver it can be done quickly and easily through multiple websites. The steps below outline how this is done. For the couriers listed, they will come and collect the package from the collection address you specify. Since the kits contain lithium polymer batteries there are some restrictions around shipping. We have confirmed that the couriers listed below are happy with shipping packages containing the size and quantity of batteries provided in the kit. Step-by-step instructions for more couriers will be added to this page in due course.","title":"Arranging a Courier"},{"location":"team_admin/kit_shipping/#kit-details","text":"Dimensions: 48cm x 39cm x 20cm Weight: 6kg Value (for insurance): \u00a3500 Batteries: Lithium Ion. Packed with equipment. Batteries less than 100Wh. In all circumstances a shipment of a kit must have at least \u00a3500 worth of insurance.","title":"Kit Details"},{"location":"team_admin/kit_shipping/#interlink","text":"Go to http://www.interlinkdirect.co.uk/ . Fill in the delivery and collection postcodes in the 'Quote/Send A Parcel' section, enter your email address and click 'Send A Parcel Within UK'. Enter the dimensions and weight from the Kit Details section and click next. Select the 'Next Day' service and 'Collection Tomorrow or later' (please do not select 'Collect Today' if you are arranging for a kit to be collected from us as we need time to prepare for the courier). Choose '\u00a3500' from the 'Extended Liability Cover' drop-down and click next. Enter the collection address. If you are arranging for a kit to be collected from us then please use the address you have been given by the Kit Logistics Coordinator. Also, if you are arranging for collection from us, please chose a collection date a couple of days in the future. Click next. Enter the delivery address. If you are arranging for a kit to be sent to us then please use the address you have been given by the Kit Logistics Coordinator. Set the 'Description of Contents' to 'Other' and enter 'Robotics kit' in the 'Description (if other)' field. Click next. Follow the instructions on the remaining pages to pay. Please double check all of the information on the 'Shipping Confirmation' page before paying. You will now receive a shipping label. If you are arranging for a kit to be collected from us then please email this to logistics@studentrobotics.org immediately. If you are sending a kit to us, please attach the shipping label to the package. If you're getting the package collected from a school, please ensure that you leave it with the reception desk and that they are aware it is being collected.","title":"Interlink"},{"location":"team_admin/user_accounts/","text":"User Accounts \u00b6 Your User Account can be used to access the various online services that we host. These include the forums , IDE and, for team-leaders, a user management interface (see below ). Getting an Account \u00b6 If you don't yet have an account, you should contact your team-leader, usually your teacher, who will be able to create one for you. They will need: Your first and last names Your email address \u2014 be sure to give them one you use regularly since we will very occasionally send you important information to it Which team you are in (if there is more than one team at your college) Once your team leader has entered your details into the user management interface you will receive an email with a link to activate your account. Please allow at least 10 minutes for the email to be sent, however if you've been waiting longer than this you should check with your team-leader that the account was created, and ask them to email < accounts@example.com > if the problem remains. Forgotten Something? \u00b6 If you forget your user name or password, you should contact your team-leader, usually your teacher. They will be able to tell you the details of your account, or reset your password for you. Password Change \u00b6 If you know your password, but want to change it, you can do this using the self service side of the user management page . Other Problems \u00b6 If your team-leader was unable to resolve your account issue, you can ask them to email accounts@example.com for more help. User management for Team Leaders \u00b6 Account creation \u00b6 To create user accounts, visit the user management page , and log in. In a column on the left, you'll see a list of users currently registered for your team. At the bottom is a link marked 'Register users'. Click on this, and you'll be presented with a form for user details. Fill this in (adding rows as appropriate), click submit, and we'll begin the account creation process. Once you've submitted this data, you'll receive an email confirming the registration. We'll also email the user to confirm their email address, and to give them their usernames and passwords. If they don't confirm their email address within two days, you'll get an email saying that their registration expired; if this happens, you will need to re-register them. Team Leaders \u00b6 When an account is created it starts off as a competitor account. In order to allow your fellow team leaders to have full access to the user management pages (among other things), you should change them to being a team leader account. You can change the type of an account in the user management page : Select the user in question from the list on the left hand side Under 'Type' change the selection to 'Team Leader' Click 'Submit' to save the changes Feel free to add as many team leader accounts as you like; there's no upper limit. Account maintenance \u00b6 If you need to update any user account data, find their username, reset their password or so forth, first log into the user management page . Once there, you should find the users name in the list of registered users on the left, as well as their username. To check or update their details, click on their name, and their registration details will appear to the right. If you wish to edit their details, including changing their password, alter the fields in this window and then click 'Submit'. Passwords \u00b6 We are unable to recover passwords once they have been set. If users forget passwords, please find their account as described above and click the 'Send password reset' button at the bottom of the page. This will send the user a single-use link to reset their password. If you forget your own password, please contact accounts@example.com .","title":"User Accounts"},{"location":"team_admin/user_accounts/#user-accounts","text":"Your User Account can be used to access the various online services that we host. These include the forums , IDE and, for team-leaders, a user management interface (see below ).","title":"User Accounts"},{"location":"team_admin/user_accounts/#getting-an-account","text":"If you don't yet have an account, you should contact your team-leader, usually your teacher, who will be able to create one for you. They will need: Your first and last names Your email address \u2014 be sure to give them one you use regularly since we will very occasionally send you important information to it Which team you are in (if there is more than one team at your college) Once your team leader has entered your details into the user management interface you will receive an email with a link to activate your account. Please allow at least 10 minutes for the email to be sent, however if you've been waiting longer than this you should check with your team-leader that the account was created, and ask them to email < accounts@example.com > if the problem remains.","title":"Getting an Account"},{"location":"team_admin/user_accounts/#forgotten-something","text":"If you forget your user name or password, you should contact your team-leader, usually your teacher. They will be able to tell you the details of your account, or reset your password for you.","title":"Forgotten Something?"},{"location":"team_admin/user_accounts/#password-change","text":"If you know your password, but want to change it, you can do this using the self service side of the user management page .","title":"Password Change"},{"location":"team_admin/user_accounts/#other-problems","text":"If your team-leader was unable to resolve your account issue, you can ask them to email accounts@example.com for more help.","title":"Other Problems"},{"location":"team_admin/user_accounts/#user-management-for-team-leaders","text":"","title":"User management for Team Leaders"},{"location":"team_admin/user_accounts/#account-creation","text":"To create user accounts, visit the user management page , and log in. In a column on the left, you'll see a list of users currently registered for your team. At the bottom is a link marked 'Register users'. Click on this, and you'll be presented with a form for user details. Fill this in (adding rows as appropriate), click submit, and we'll begin the account creation process. Once you've submitted this data, you'll receive an email confirming the registration. We'll also email the user to confirm their email address, and to give them their usernames and passwords. If they don't confirm their email address within two days, you'll get an email saying that their registration expired; if this happens, you will need to re-register them.","title":"Account creation"},{"location":"team_admin/user_accounts/#team-leaders","text":"When an account is created it starts off as a competitor account. In order to allow your fellow team leaders to have full access to the user management pages (among other things), you should change them to being a team leader account. You can change the type of an account in the user management page : Select the user in question from the list on the left hand side Under 'Type' change the selection to 'Team Leader' Click 'Submit' to save the changes Feel free to add as many team leader accounts as you like; there's no upper limit.","title":"Team Leaders"},{"location":"team_admin/user_accounts/#account-maintenance","text":"If you need to update any user account data, find their username, reset their password or so forth, first log into the user management page . Once there, you should find the users name in the list of registered users on the left, as well as their username. To check or update their details, click on their name, and their registration details will appear to the right. If you wish to edit their details, including changing their password, alter the fields in this window and then click 'Submit'.","title":"Account maintenance"},{"location":"team_admin/user_accounts/#passwords","text":"We are unable to recover passwords once they have been set. If users forget passwords, please find their account as described above and click the 'Send password reset' button at the bottom of the page. This will send the user a single-use link to reset their password. If you forget your own password, please contact accounts@example.com .","title":"Passwords"},{"location":"troubleshooting/","text":"Troubleshooting \u00b6 If you are experiencing problems with either the Student Robotics hardware, IDE or python library you should check here first to see if there is a simple solution. If you don't find the information you need in this section you can use the forum to get help with your specific problem. sr.robot python library issues \u2014 Common problems with the sr.robot python library and possible solutions. Interactive Troubleshooter \u2014 Consider using the Interactive Troubleshooter to narrow down your problem and find a solution. General Troubleshooting Tips \u00b6 Simplify the task By reducing the complexity of whatever you're trying to do, the chances that you've overlooked something are smaller. It also allows you to rule out a collection of things which could be causing the issue and makes the system easier to understand. In turn, that means that if you do need to get help from someone else you don't need to spend a long time explaining what's going on. Explain it to someone else By explaining the system to someone else, even (and for some reason especially ) an inanimate object , you're forced to think about each piece of the system and describe what it does and how it works. This often leads you to realise which part of the system isn't working, without any actual input from the other person. Check the log file for errors If your program has an error in it, it will stop running or not run at all. Check the log file either through the robot WiFi interface or look at the log file on the USB stick to see any error reports. Print all the things Adding print statements into the code you're working on allows you to track the progress of the system while it is running. When working on non-software systems other mechanisms are used to achieve the same goal \u2014 LEDs commonly used for this in electronics hardware, and this is part of the reason our boards are covered in them. On the robots the output from any print statements will end up in the log file , which can be viewed either in the robot WiFi interface or on the USB stick. Check the docs It's very easy to end up thinking that you know how something works and then forget something out of familiarity. By double-checking the appropriate docs (be it for the kit , for Python or for the extra thing you've bought) you can be completely sure that you've not missed something.","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"If you are experiencing problems with either the Student Robotics hardware, IDE or python library you should check here first to see if there is a simple solution. If you don't find the information you need in this section you can use the forum to get help with your specific problem. sr.robot python library issues \u2014 Common problems with the sr.robot python library and possible solutions. Interactive Troubleshooter \u2014 Consider using the Interactive Troubleshooter to narrow down your problem and find a solution.","title":"Troubleshooting"},{"location":"troubleshooting/#general-troubleshooting-tips","text":"Simplify the task By reducing the complexity of whatever you're trying to do, the chances that you've overlooked something are smaller. It also allows you to rule out a collection of things which could be causing the issue and makes the system easier to understand. In turn, that means that if you do need to get help from someone else you don't need to spend a long time explaining what's going on. Explain it to someone else By explaining the system to someone else, even (and for some reason especially ) an inanimate object , you're forced to think about each piece of the system and describe what it does and how it works. This often leads you to realise which part of the system isn't working, without any actual input from the other person. Check the log file for errors If your program has an error in it, it will stop running or not run at all. Check the log file either through the robot WiFi interface or look at the log file on the USB stick to see any error reports. Print all the things Adding print statements into the code you're working on allows you to track the progress of the system while it is running. When working on non-software systems other mechanisms are used to achieve the same goal \u2014 LEDs commonly used for this in electronics hardware, and this is part of the reason our boards are covered in them. On the robots the output from any print statements will end up in the log file , which can be viewed either in the robot WiFi interface or on the USB stick. Check the docs It's very easy to end up thinking that you know how something works and then forget something out of familiarity. By double-checking the appropriate docs (be it for the kit , for Python or for the extra thing you've bought) you can be completely sure that you've not missed something.","title":"General Troubleshooting Tips"},{"location":"troubleshooting/python/","text":"Python Troubleshooting \u00b6 This is just a selection of common error messages. If you encounter one that isn't on this list, quickly check your code and search the Internet for it. Reading the Logs \u00b6 When your program runs on the robot, the output of print statements and any errors which occur are written to a log file. You can view this log file via the robot WiFi interface (by touching the menu icon in the top-left, followed by \"Logs\"). It is also written to the USB stick as log.txt . Syntax Error \u00b6 This error message appears when you have entered a statement that doesn't obey the forms of the language. For example: def foo ( s ): print s foo \"Hello World!\" # should be foo(\"Hello World!\") Error: File \"<stdin>\", line 4 foo \"Hello World!\" ^ SyntaxError: invalid syntax The output shows a problem with the fourth line, where we've forgotten to place brackets around the string parameter. The arrow indicates the place where the interpreter thinks the problem is. As you can see, this could often be more helpful. Other causes of syntax errors to look out for are: Missing colons at the end of def s, if s, for s, etc. Using the wrong number of = signs (see the Variables section) Missing brackets (e.g. x = 5 * (3+2 ). For those outside of the U.K., the decimal point is a period ( . ), not a comma ( , ) Name Error \u00b6 x = 5 print X # wrong case Error: Traceback (most recent call last): File \"<stdin>\", line 2, in <module> NameError: name 'X' is not defined This error has occurred because the variable was defined as x , but referenced as X in uppercase. As previously alluded to, Python distinguishes between cases, so these are two different variables. This error has a traceback. This would list the functions that the error occurred in, if it was inside a function. Index Error \u00b6 If you try to access an element of a list that does not exist, you'll get this error. For example: a = [ \"Molly\" , \"Polly\" , \"Dolly\" ] print a [ 0 ] print a [ 3 ] Error: Traceback (most recent call in last): File \"<stdin>\", line 1, in <module> IndexError: list index out of range This example illustrates a common cause. As a has three elements, you'd expect it to have a third element. However, in Python, the 'first' element is number 0, the 'second' is number 1, and so on. So, the last element in the array is actually number 2, and element number 3 doesn't exist. Indentation Error \u00b6 If you forget to indent some code, or mix tabs and spaces , you will get an indentation error. For example: if x < 5 : do_some_stuff () Error: File \"<stdin>\", line 2 do_some_stuff() ^ IndentationError: expected an indented block Type Error \u00b6 Variables in Python not only have a value, but also a type. This might be a string (some characters), an integer (whole number), a float (number with a decimal point), a robot (your Robot() variable) or something else. When you use these variables, you have to make sure that the types match. This means that you cannot do something like this: a = \"36\" b = 48 c = a + b Here a is a string, and adding it to b , which is an integer, is not a valid operation. You either have to turn the a into an integer by doing int(a) or turn b into a string by doing str(b) . d = int ( a ) + b # 84 e = a + str ( b ) # \"3648\" If you make a mistake while interacting with variables of different types, you'll get a TypeError containing some information about how to fix the problem.","title":"Python Troubleshooting"},{"location":"troubleshooting/python/#python-troubleshooting","text":"This is just a selection of common error messages. If you encounter one that isn't on this list, quickly check your code and search the Internet for it.","title":"Python Troubleshooting"},{"location":"troubleshooting/python/#reading-the-logs","text":"When your program runs on the robot, the output of print statements and any errors which occur are written to a log file. You can view this log file via the robot WiFi interface (by touching the menu icon in the top-left, followed by \"Logs\"). It is also written to the USB stick as log.txt .","title":"Reading the Logs"},{"location":"troubleshooting/python/#syntax-error","text":"This error message appears when you have entered a statement that doesn't obey the forms of the language. For example: def foo ( s ): print s foo \"Hello World!\" # should be foo(\"Hello World!\") Error: File \"<stdin>\", line 4 foo \"Hello World!\" ^ SyntaxError: invalid syntax The output shows a problem with the fourth line, where we've forgotten to place brackets around the string parameter. The arrow indicates the place where the interpreter thinks the problem is. As you can see, this could often be more helpful. Other causes of syntax errors to look out for are: Missing colons at the end of def s, if s, for s, etc. Using the wrong number of = signs (see the Variables section) Missing brackets (e.g. x = 5 * (3+2 ). For those outside of the U.K., the decimal point is a period ( . ), not a comma ( , )","title":"Syntax Error"},{"location":"troubleshooting/python/#name-error","text":"x = 5 print X # wrong case Error: Traceback (most recent call last): File \"<stdin>\", line 2, in <module> NameError: name 'X' is not defined This error has occurred because the variable was defined as x , but referenced as X in uppercase. As previously alluded to, Python distinguishes between cases, so these are two different variables. This error has a traceback. This would list the functions that the error occurred in, if it was inside a function.","title":"Name Error"},{"location":"troubleshooting/python/#index-error","text":"If you try to access an element of a list that does not exist, you'll get this error. For example: a = [ \"Molly\" , \"Polly\" , \"Dolly\" ] print a [ 0 ] print a [ 3 ] Error: Traceback (most recent call in last): File \"<stdin>\", line 1, in <module> IndexError: list index out of range This example illustrates a common cause. As a has three elements, you'd expect it to have a third element. However, in Python, the 'first' element is number 0, the 'second' is number 1, and so on. So, the last element in the array is actually number 2, and element number 3 doesn't exist.","title":"Index Error"},{"location":"troubleshooting/python/#indentation-error","text":"If you forget to indent some code, or mix tabs and spaces , you will get an indentation error. For example: if x < 5 : do_some_stuff () Error: File \"<stdin>\", line 2 do_some_stuff() ^ IndentationError: expected an indented block","title":"Indentation Error"},{"location":"troubleshooting/python/#type-error","text":"Variables in Python not only have a value, but also a type. This might be a string (some characters), an integer (whole number), a float (number with a decimal point), a robot (your Robot() variable) or something else. When you use these variables, you have to make sure that the types match. This means that you cannot do something like this: a = \"36\" b = 48 c = a + b Here a is a string, and adding it to b , which is an integer, is not a valid operation. You either have to turn the a into an integer by doing int(a) or turn b into a string by doing str(b) . d = int ( a ) + b # 84 e = a + str ( b ) # \"3648\" If you make a mistake while interacting with variables of different types, you'll get a TypeError containing some information about how to fix the problem.","title":"Type Error"},{"location":"tutorials/","text":"Tutorials \u00b6 Read the following tutorials listed in order of difficulty: Basic Motor Control \u2014 all you need to know to get your motors moving Python: A whirlwind tour \u2014 an overview of how to use python","title":"Tutorials"},{"location":"tutorials/#tutorials","text":"Read the following tutorials listed in order of difficulty: Basic Motor Control \u2014 all you need to know to get your motors moving Python: A whirlwind tour \u2014 an overview of how to use python","title":"Tutorials"},{"location":"tutorials/basic_motor_control/","text":"Basic Motor Control \u00b6 The aim of this tutorial is to get a motor turning with your kit. To complete this tutorial, you'll need the following: The power board The battery (charged, of course) The cable to connect the battery to the power board A motor board 2 large (7.5mm) green CamCon connectors to plug the power board and motor board together 2 lengths of a suitable gauge of wire for powering the motor board from the power board (one should be black/grey) A motor (see specification below) A small (5mm) green CamCon connector to plug the motor and motor board together 2 lengths of a suitable gauge of wire for your motor A Micro USB cable A USB hub A standard USB cable The memory stick A soldering Iron Some solder wire Wire strippers A small slotted/flat blade screwdriver (for the CamCon screws) You should be familiar with the setup for most of the above now, so it's just the motor-related parts that need explaining. Motor Specification \u00b6 There is a certain specification the motor(s) you use must meet. The criteria are as follows: 12V motor A stall current of less than 10A (this is the current limit for the motor boards ) When designing your robot you should bear in mind that while each motor board can deliver 10A on each output, all the power needs to go through the power board, which is fused at 15A. This means that across all the outputs for all the motors, you can only draw up to 15A at any time. Connecting a Motor \u00b6 To plug the motor into the kit, you'll need to solder an appropriate gauge of wire to the terminals on the motor, and connect the other ends to the CamCon connector. Like so: You may want to insulate the motor's terminals with some insulation tape (or heat shrink tubing if you've got it) like in the image above. Now you need to connect the motor to one of your motor boards. You'll need to connect the following: Your motor into the motor 0 socket on the motor board The micro USB cable from the motor board to the USB hub The standard USB cable from the USB hub to the power board This is almost ready, but the motor board also needs the power that it will be delivering to the motor. This is done by connecting together the two larger CamCon connectors, using the other two lengths of wire. Be sure that the cable connects the positive motor rail output (\"+\") of the power board to the positive power input of the motor board, and likewise for the ground (\"-\") output \u2014 see the power board and motor board documentation to see which is which. You must always use black or grey for ground (0V) connections (and only for these), so that it's clear where these are. You can now connect this into the power board on one end, and the motor board power connection on the other. Some Code \u00b6 You might want to ensure the motor won't take the kit anywhere when you press the run button when testing some of the below code (unless it's in a robot, of course). The example program we'll write will do a number of things with the motor: forwards and backwards, and different power settings, for example. Let's begin. To start off with, we'll just make a motor move forwards, then backwards, and then repeat. Forwards & Backwards \u00b6 Doing this is actually very easy; the only thing you need to realise is that a positive number is forwards and a negative number is backwards. The actual direction of travel of a motor, when mounted on a robot, will depend on its orientation and the way in which the wires are connected to the motor board. If the motor appears to be going in the wrong direction, just swap the motor's positive and negative wires over. Here's the code: from sr.robot import * import time R = Robot () while True : R . motors [ 0 ] . m0 . power = 50 time . sleep ( 3.0 ) R . motors [ 0 ] . m0 . power = 0 time . sleep ( 1.4 ) R . motors [ 0 ] . m0 . power = - 50 time . sleep ( 1 ) R . motors [ 0 ] . m0 . power = 0 time . sleep ( 4 ) You're familiar with the first few lines; in fact, the only lines you may not be familiar with are the R.motors[0]... lines. For a comprehensive reference to the motor object, see the sr.robot module's motor page. But, to summarise: `R.motors[0].m0.power = x` will set the power of the motor connected to output 0 (the `m0` part) on the first [motor board](/docs/kit/motor_board) (the `motors[0]` part) plugged in to a USB hub to `x`, where `x` is a value between `-100` and `100`, inclusive \u2014 in other words: `-100` \u2264 `x` \u2264 `100`. So, R.motors[0].m0.power = 50 sets the target power of the motor connected to output 0 on the first motor board plugged in to a USB hub to 50% forwards (i.e. a duty-cycle of 0.5 forwards). As you would expect, then, R.motors[0].m0.power = -50 will put the this motor into reverse at 50% power. R.motors[0].m0.power = 0 will output no power to the motor and stop it. So, if you put the above code on your robot, you should be able to see a motor spin forwards, stop, spin backwards, stop, and then repeat... If you find that the motor doesn't turn when you run the above code, check that you've got all the cables connected to the right places, in particular note that the motor board has _two_ outputs. Changing the Speed \u00b6 Now we're going to modify the program to vary the speed of the motor. Our aim is to do the forwards and backwards bit (as above), but, before we loop round again, ramp the power up to 70%, then down to -70%, and then back to 0 (all in steps of 10%). Here's the code: from sr.robot import * import time R = Robot () while True : R . motors [ 0 ] . m0 . power = 50 time . sleep ( 3.0 ) R . motors [ 0 ] . m0 . power = 0 time . sleep ( 1.4 ) R . motors [ 0 ] . m0 . power = - 50 time . sleep ( 1 ) R . motors [ 0 ] . m0 . power = 0 time . sleep ( 4 ) # ^^ code from before ^^ # power up to 70 (from 10) for pwr in range ( 10 , 80 , 10 ): R . motors [ 0 ] . m0 . power = pwr time . sleep ( 0.1 ) # power down from 70 (to 10) for pwr in range ( 70 , 0 , - 10 ): R . motors [ 0 ] . m0 . power = pwr time . sleep ( 0.1 ) # set power to 0 for a second R . motors [ 0 ] . m0 . power = 0 time . sleep ( 1 ) # power \"up\" to -70 (from -10) for pwr in range ( - 10 , - 80 , - 10 ): R . motors [ 0 ] . m0 . power = pwr time . sleep ( 0.1 ) # power \"down\" to -10 (from -70) for pwr in range ( - 70 , 0 , 10 ): R . motors [ 0 ] . m0 . power = pwr time . sleep ( 0.1 ) # set power to 0 for a second R . motors [ 0 ] . m0 . power = 0 time . sleep ( 1 ) Again, as you've seen most of that before, it shouldn't be too difficult to get your head around. The for loop may be new, however. The for loop accepts a Python list (a list , when print ed, appears in square brackets like so: [1, 2, 3] ). For a comprehensive introduction to to list s, have a look at this WikiBooks article . The for loop will iterate over the list (i.e. take each element in turn) and make it available in the loop's body as the variable after the the for keyword. Here's an example: for i in [ 1 , 2 , 3 ]: print i The above would output: 1 2 3 Then there's the range() function. The range() function returns a list with its contents dependent on the arguments passed to it. The Python documentation explains it quite nicely: range([start], stop[, step]) (note: the square brackets here mean 'optional') If the step argument is omitted, it defaults to 1 . If the start argument is omitted, it defaults to 0 . The full form returns a list of plain integers [start, start + step, start + 2 * step, ...] . If step is positive, the last element is the largest start + i * step less than stop ; if step is negative, the last element is the smallest start + i * step greater than stop . So, based on that, range(3) would return the list [0, 1, 2] because it is shorthand for range(0, 3, 1) . From the quote, you can see that this would return a list starting from 0 , and finishing with the integer one less than 3 , hence the [0, 1, 2] . So, taking range(10, 80, 10) , for example, would output 10 as the first element, then 20, 30, ... up until x=10+i*10 for some i where i ensures x < stop (which, in this case, is 80 ). So, the 80 I've used could equally have been 77 or even 71 and the outputted list would still be [10, 20, 30, 40, 50, 60, 70] . Putting all of that together should mean you understand the above code. You might want to run the code on your kit to see if it does what you expect it to. Next Steps \u00b6 From here, you should be able to make your robot move about in a controlled manner. See if you can make your robot drive forwards to a given point, stop, turn around and then return to its starting point. You might also like to see if you can make the larger code example above more concise by creating functions for the repetitive parts. This tutorial seems good if you're interested.","title":"Basic Motor Control"},{"location":"tutorials/basic_motor_control/#basic-motor-control","text":"The aim of this tutorial is to get a motor turning with your kit. To complete this tutorial, you'll need the following: The power board The battery (charged, of course) The cable to connect the battery to the power board A motor board 2 large (7.5mm) green CamCon connectors to plug the power board and motor board together 2 lengths of a suitable gauge of wire for powering the motor board from the power board (one should be black/grey) A motor (see specification below) A small (5mm) green CamCon connector to plug the motor and motor board together 2 lengths of a suitable gauge of wire for your motor A Micro USB cable A USB hub A standard USB cable The memory stick A soldering Iron Some solder wire Wire strippers A small slotted/flat blade screwdriver (for the CamCon screws) You should be familiar with the setup for most of the above now, so it's just the motor-related parts that need explaining.","title":"Basic Motor Control"},{"location":"tutorials/basic_motor_control/#motor-specification","text":"There is a certain specification the motor(s) you use must meet. The criteria are as follows: 12V motor A stall current of less than 10A (this is the current limit for the motor boards ) When designing your robot you should bear in mind that while each motor board can deliver 10A on each output, all the power needs to go through the power board, which is fused at 15A. This means that across all the outputs for all the motors, you can only draw up to 15A at any time.","title":"Motor Specification"},{"location":"tutorials/basic_motor_control/#connecting-a-motor","text":"To plug the motor into the kit, you'll need to solder an appropriate gauge of wire to the terminals on the motor, and connect the other ends to the CamCon connector. Like so: You may want to insulate the motor's terminals with some insulation tape (or heat shrink tubing if you've got it) like in the image above. Now you need to connect the motor to one of your motor boards. You'll need to connect the following: Your motor into the motor 0 socket on the motor board The micro USB cable from the motor board to the USB hub The standard USB cable from the USB hub to the power board This is almost ready, but the motor board also needs the power that it will be delivering to the motor. This is done by connecting together the two larger CamCon connectors, using the other two lengths of wire. Be sure that the cable connects the positive motor rail output (\"+\") of the power board to the positive power input of the motor board, and likewise for the ground (\"-\") output \u2014 see the power board and motor board documentation to see which is which. You must always use black or grey for ground (0V) connections (and only for these), so that it's clear where these are. You can now connect this into the power board on one end, and the motor board power connection on the other.","title":"Connecting a Motor"},{"location":"tutorials/basic_motor_control/#some-code","text":"You might want to ensure the motor won't take the kit anywhere when you press the run button when testing some of the below code (unless it's in a robot, of course). The example program we'll write will do a number of things with the motor: forwards and backwards, and different power settings, for example. Let's begin. To start off with, we'll just make a motor move forwards, then backwards, and then repeat.","title":"Some Code"},{"location":"tutorials/basic_motor_control/#forwards-backwards","text":"Doing this is actually very easy; the only thing you need to realise is that a positive number is forwards and a negative number is backwards. The actual direction of travel of a motor, when mounted on a robot, will depend on its orientation and the way in which the wires are connected to the motor board. If the motor appears to be going in the wrong direction, just swap the motor's positive and negative wires over. Here's the code: from sr.robot import * import time R = Robot () while True : R . motors [ 0 ] . m0 . power = 50 time . sleep ( 3.0 ) R . motors [ 0 ] . m0 . power = 0 time . sleep ( 1.4 ) R . motors [ 0 ] . m0 . power = - 50 time . sleep ( 1 ) R . motors [ 0 ] . m0 . power = 0 time . sleep ( 4 ) You're familiar with the first few lines; in fact, the only lines you may not be familiar with are the R.motors[0]... lines. For a comprehensive reference to the motor object, see the sr.robot module's motor page. But, to summarise: `R.motors[0].m0.power = x` will set the power of the motor connected to output 0 (the `m0` part) on the first [motor board](/docs/kit/motor_board) (the `motors[0]` part) plugged in to a USB hub to `x`, where `x` is a value between `-100` and `100`, inclusive \u2014 in other words: `-100` \u2264 `x` \u2264 `100`. So, R.motors[0].m0.power = 50 sets the target power of the motor connected to output 0 on the first motor board plugged in to a USB hub to 50% forwards (i.e. a duty-cycle of 0.5 forwards). As you would expect, then, R.motors[0].m0.power = -50 will put the this motor into reverse at 50% power. R.motors[0].m0.power = 0 will output no power to the motor and stop it. So, if you put the above code on your robot, you should be able to see a motor spin forwards, stop, spin backwards, stop, and then repeat... If you find that the motor doesn't turn when you run the above code, check that you've got all the cables connected to the right places, in particular note that the motor board has _two_ outputs.","title":"Forwards &amp; Backwards"},{"location":"tutorials/basic_motor_control/#changing-the-speed","text":"Now we're going to modify the program to vary the speed of the motor. Our aim is to do the forwards and backwards bit (as above), but, before we loop round again, ramp the power up to 70%, then down to -70%, and then back to 0 (all in steps of 10%). Here's the code: from sr.robot import * import time R = Robot () while True : R . motors [ 0 ] . m0 . power = 50 time . sleep ( 3.0 ) R . motors [ 0 ] . m0 . power = 0 time . sleep ( 1.4 ) R . motors [ 0 ] . m0 . power = - 50 time . sleep ( 1 ) R . motors [ 0 ] . m0 . power = 0 time . sleep ( 4 ) # ^^ code from before ^^ # power up to 70 (from 10) for pwr in range ( 10 , 80 , 10 ): R . motors [ 0 ] . m0 . power = pwr time . sleep ( 0.1 ) # power down from 70 (to 10) for pwr in range ( 70 , 0 , - 10 ): R . motors [ 0 ] . m0 . power = pwr time . sleep ( 0.1 ) # set power to 0 for a second R . motors [ 0 ] . m0 . power = 0 time . sleep ( 1 ) # power \"up\" to -70 (from -10) for pwr in range ( - 10 , - 80 , - 10 ): R . motors [ 0 ] . m0 . power = pwr time . sleep ( 0.1 ) # power \"down\" to -10 (from -70) for pwr in range ( - 70 , 0 , 10 ): R . motors [ 0 ] . m0 . power = pwr time . sleep ( 0.1 ) # set power to 0 for a second R . motors [ 0 ] . m0 . power = 0 time . sleep ( 1 ) Again, as you've seen most of that before, it shouldn't be too difficult to get your head around. The for loop may be new, however. The for loop accepts a Python list (a list , when print ed, appears in square brackets like so: [1, 2, 3] ). For a comprehensive introduction to to list s, have a look at this WikiBooks article . The for loop will iterate over the list (i.e. take each element in turn) and make it available in the loop's body as the variable after the the for keyword. Here's an example: for i in [ 1 , 2 , 3 ]: print i The above would output: 1 2 3 Then there's the range() function. The range() function returns a list with its contents dependent on the arguments passed to it. The Python documentation explains it quite nicely: range([start], stop[, step]) (note: the square brackets here mean 'optional') If the step argument is omitted, it defaults to 1 . If the start argument is omitted, it defaults to 0 . The full form returns a list of plain integers [start, start + step, start + 2 * step, ...] . If step is positive, the last element is the largest start + i * step less than stop ; if step is negative, the last element is the smallest start + i * step greater than stop . So, based on that, range(3) would return the list [0, 1, 2] because it is shorthand for range(0, 3, 1) . From the quote, you can see that this would return a list starting from 0 , and finishing with the integer one less than 3 , hence the [0, 1, 2] . So, taking range(10, 80, 10) , for example, would output 10 as the first element, then 20, 30, ... up until x=10+i*10 for some i where i ensures x < stop (which, in this case, is 80 ). So, the 80 I've used could equally have been 77 or even 71 and the outputted list would still be [10, 20, 30, 40, 50, 60, 70] . Putting all of that together should mean you understand the above code. You might want to run the code on your kit to see if it does what you expect it to.","title":"Changing the Speed"},{"location":"tutorials/basic_motor_control/#next-steps","text":"From here, you should be able to make your robot move about in a controlled manner. See if you can make your robot drive forwards to a given point, stop, turn around and then return to its starting point. You might also like to see if you can make the larger code example above more concise by creating functions for the repetitive parts. This tutorial seems good if you're interested.","title":"Next Steps"},{"location":"tutorials/python/","text":"Python: A whirlwind tour \u00b6 In this tutorial, we'll introduce the basic concepts of programming, which will be central to the programs that you will run on your robot. There are many different languages in which computers can be programmed, all with their advantages and disadvantages, but for the Student Robotics competition we use one called Python 2.6. We chose it because it's good for beginners, but also elegant and powerful. Sprinkled through the tutorial are exercises. The first ones for each section should be quite easy, while the higher-numbered exercises will be harder. Some will be very hard; try these if you're up for a challenge. Before we begin: a word on learning. The way that you learn to code is by doing it; make sure you try out the examples, fiddle with them, break them, try at least one exercise from each section. So, on with the tutorial! Using an interpreter \u00b6 To run Python programs you need a something called an interpreter. This is a computer program which interprets human-readable Python code into something that the computer can execute. There are a number of online interpreters that should work even on a locked-down computer such as you will probably find in your college. If your computer has a compatible browser, go to http://repl.it and click Python. Enter your program in the box on the left, and click the arrow to run it. If your browser isn't compatible, another good online interpreter can be found at http://codeskulptor.org . It's very similar; simply enter your program into the left pane and click the play button to run it. The output will appear in the right pane. Whichever you choose, test it with this classic one line program: print \"Hello World!\" The text Hello World! should appear in the output box. There's nothing particularly wrong with online interpreters for our needs, but if you want to use Python for something more advanced you'll want an interpreter which runs directly on your computer. Mac OS X and Linux come with one by default (just type python at the terminal), and you can download the Windows interpreter from http://python.org/download (try Portable Python ( http://portablepython.com ) if you can't install programs on your computer). Statements \u00b6 A statement is a line of code that does something. A program is a list of statements. For example: x = 5 y = ( x * 2 ) + 4 print \"Number of bees:\" , y - 2 The statements are executed one by one, in order. This example would give the output Number of bees: 12 . As you may have guessed, the print statement displays text on the screen, while the other two lines are simple algebra. Strings \u00b6 When you want the interpreter to treat something as a text value (for example, after the print statement above), you have to surround it in quotes. You can use either single ( ' ) or double ( \" ) quotes, but try to be consistent. Pieces of text that are treated like this are called 'strings'. Comments \u00b6 Placing a hash ( # ) in your program ignores anything after the hash. For example: # This is a comment print \"This isn't.\" # But this is! You should use comments whenever you think that it is not completely clear what a statement or block of statements does, especially as you are working in teams! Also bear in mind the varying coding skills of your team. You might be the best coder in your team, but what if you were taken ill the day before the competition, and your team-mates had to fix your code? Comments are also useful for temporarily removing statements from your code, for testing: x = 42 #x = x - 4 print \"The answer is\" , x This example would output The answer is 42 , as the subtraction is not executed. Variables \u00b6 Variables store values for later use, as in the first example. They can store many different things, but the most relevant here are numbers, strings (blocks of text), booleans ( True or False ) and lists (which we'll come to later). To set a variable, simply give its name (see [Identifiers], below), followed by = and a value. For example: x = 8 my_string = \"Tall ship\" You can ask the user to put some text into a variable with the raw_input function (we'll cover functions in more detail later): name = raw_input ( \"What is your name?\" ) Concept: Identifiers \u00b6 Certain things in your program, for example variables and functions, will need names. These names are called 'identifiers', and must follow these rules: Identifiers can contain letters, digits, and underscores. They may not contain spaces or other symbols. An identifier cannot begin with a digit. Identifiers are case sensitive. This means that bees , Bees and BEES are three different identifiers. Exercises: Variables and Mathematics \u00b6 Average calculator \u00b6 The first two lines of this program put two numbers entered by the user into variables a and b . (The input function is like raw_input , but returns a number (e.g. 42 ) when you enter one, rather than a string (like \"42\" ).) Replace the comment with code that averages the numbers and puts them in a variable called average . a = input ( \"Enter first number: \" ) b = input ( \"Enter second number: \" ) # Store the average of a and b in the variable `average` print \"The average of\" , a , \"and\" , b , \"is\" , average Run your code and check that it works. Distance calculator \u00b6 Write a program which uses input to take an X and a Y coordinate, and calculate the distance from (0, 0) to (X, Y) using Pythagoras' Theorem. Put the code into an interpreter and run it. Does it do what you expected? Hint: you can find the square root of a number by raising it to the power of 0.5, for example, my_number ** 0.5 . Extension: can you adapt the program to calculate the distance between any two points? Booleans and if statements \u00b6 A boolean value is either True or False . For example: print 42 > 5 print 4 == 2 Output: True False < and == are operators, just like + or * , which return booleans. Others include <= (less than or equal to), > , >= and != (not equal to) (see the Operators appendix). You can also use and , or , and not . if statements execute code only if their condition is true. The code to include in the if is denoted by a number of indented lines (see the concept section on [code blocks][block]). To indent a line, press the tab key or insert four spaces at the start. You can also include an else statement, which is executed if the condition is false. For example: name = raw_input ( \"What is your name?\" ) if name == \"Tim\" : print \"Hello Tim.\" print \"You've got an email.\" else : print \"You're not Tim!\" print \"Python rocks!\" If you typed \"Tim\" at the prompt, this example would output: Hello Tim. You've got an email. Python rocks! Having another if in the else block is very common: price = 50000 * 1.3 if price < 60000 : print \"We can afford the tall ship!\" else : if price < 70000 : print \"We might be able to afford the tall ship...\" else : print \"We can't afford the tall ship. :-(\" So common that there's a special keyword, elif , for the purpose. So, the following piece of code is equivalent to the last: price = 50000 * 1.3 if price < 60000 : print \"We can afford the tall ship!\" elif price < 70000 : print \"We might be able to afford the tall ship...\" else : print \"We can't afford the tall ship. :-(\" Both output: We might be able to afford the tall ship... Concept: Code blocks and indentation \u00b6 In the previous section, you probably noticed that the statements 'inside' the if statements were indented relative to the rest of the code. Python is reasonably unique in that it cares about indentation, and uses it to decide which statements are referred to by things like if statements. In most other programming languages, if you don't indent your code it will run just fine, but any poor soul who has to read your code afterwards will hunt you down and hit you around the head with a large, wet fish. In Python, you'll just get an error, which we're sure you'll agree is preferable. A group of consecutive statements that are all indented by the same distance is called a block. if statements, as well as functions and loops, all refer to the block that follows them, which must be indented further than that statement. An example is in order. Let's expand the first if example: name = raw_input ( \"What is your name?\" ) email = \"Bank of Nigeria: Tax Refund\" if name == \"Tim\" : print \"Hello Tim.\" if email != \"\" : print \"You've got an email.\" # (blocks can contain blank lines in the middle) if email != \"Bank of Nigeria: Tax Refund\" : print \"Looks legitimate, too!\" else : print \"No mail.\" else : print \"You're not Tim!\" print \"Python rocks.\" Output (for \"Tim\" as before): Hello Tim. You've got an email! Python rocks. To find the limits of an if statement, just scan straight down until you encounter another statement on the same indent level. Play around with this example until you understand what's happening. One final thing: Python doesn't mind how you indent lines, just so long as you're consistent. Some text editors insert indent characters when you press tab; others insert spaces (normally four). They'll often look the same, but cause errors if they're mixed. If you're using an online interpreter, you probably don't need to worry. Otherwise, check your editor's settings to make sure they're consistent. Four spaces per indent level is the convention in Python. We'll now move on from this topic before that last sentence causes a flame war. Exercises: if Statements and Blocks \u00b6 So many if s \u00b6 Without running it, work out what output the following code will give: some_text = \"Duct Tape\" if 5 > 4 : print \"Maths works.\" if some_text == \"duct tape\" : print \"The case is wrong.\" elif some_text == \"Duct Tape\" : print \"That's right.\" else : print \"Completely wrong.\" else : print \"Oh-oh.\" Run the code and check your prediction. Age Discrimination Tool \u00b6 Write a program that asks the user for their age, and prints a different message depending on whether they are under 18, over 65, or in between. Lists \u00b6 Lists store more than one value in a single variable, and allow you to set and retrieve values by their position ('index') in the list. For example: shopping_list = [ \"Bread\" , \"Milk\" , \"PNP Transistors\" , \"Newspaper\" ] print shopping_list [ 0 ] shopping_list [ 3 ] = \"Magazine\" print shopping_list [ 2 ] print shopping_list [ 3 ] Output: Bread PNP Transistors Magazine Notice that the indices start at 0, not 1. There is a sensible, technical explanation for this that is beyond this tutorial's scope. Also note that because of this, the last element of this four-element list is at index 3. Attempting to retrieve shopping_list[4] would cause an error. You can find out the length of a list with the len function, like so: shopping_list = [ \"Bread\" , \"Milk\" , \"PNP Transistors\" , \"Newspaper\" ] print \"There are\" , len ( shopping_list ), \"items on your list.\" Finally, you can add a value to the end of a list with the append method: shopping_list = [ \"Bread\" , \"Milk\" , \"PNP Transistors\" , \"Newspaper\" ] shopping_list . append ( \"Mince pies in October\" ) print shopping_list The values in a list can be of any type, even other lists. Also, a list can contain values of different types. There are various other useful data structures that are beyond the scope of this tutorial, such as dictionaries (which allow indices other than numbers). You can find out more about these at http://docs.python.org/tutorial/datastructures.html . while loops \u00b6 The while loop is the most basic type of loop. It repeats the statements in the loop while a condition is true. For example: x = 10 while x > 0 : print x if x == 5 : print \"Half way there!\" x = x - 1 print \"Zero!\" Output: 10 9 8 7 6 5 Half way there! 4 3 2 1 Zero! The condition is the same as it would be in an if statement, and the block of code to put in the loop is denoted in the same way, too. for loops \u00b6 The most common application of loops is in conjunction with lists. The for loop is designed specifically for that purpose. For example: shopping_list = [ \"Bread\" , \"Milk\" , \"PNP Transistors\" , \"Newspaper\" ] for x in shopping_list : print \"[ ]\" , x The code is executed once for each item in the list, with x set to each item in turn. So, the output of this example is: [ ] Bread [ ] Milk [ ] PNP Transistors [ ] Newspaper Unfortunately, this method doesn't tell you the index of the current item. x is only a temporary variable, so modifying it has no effect on the list itself (try it). This is where the enumerate function comes in (see the Calling functions section). It tells us the index of each value we loop over. An example with numbers: prices = [ 4 , 5 , 2 , 1.50 ] # Add VAT for index , value in enumerate ( prices ): prices [ index ] = value * 1.20 print prices Output: [4.8, 6.0, 2.4, 1.7999999999999998] Exercises: Lists and Loops \u00b6 A better average calculator \u00b6 Write a program which calculates the average of a list of numbers. You can specify the list in the code. Extension: You can tell when a user has not entered anything at a raw_input prompt when it returns the empty string, \"\" . Otherwise, it returns a string (like \"42.5\"), which you can turn into a number with the float function. For example: var = raw_input ( \"Enter a number: \" ) if var == \"\" : print \"You didn't enter anything!\" else : print \"You entered\" , float ( var ) Now, extend your program to let the user enter the list of values. Stop asking for new list entries when they do not enter anything at the raw_input prompt. Fizz buzz \u00b6 Write a program which prints a list of numbers from 0 to 100, but replace numbers divisible by 3 with \"Fizz\", numbers divisible by 5 with \"Buzz\", and numbers divisible by both with \"Fizz Buzz\". Hint: you might find the range function from the next section useful. Extension: create a list of numbers, and replace a number with \"Fuzz\" if it is a multiple of any number in the list. Trees and Triangles \u00b6 You can combine (or 'concatenate') strings in Python with the + operator: str = \"Hello \" str = str + \"World!\" print str Write a program that asks the user for a number, and then prints a triangle of that height, with its right angle at the bottom left. For example, given the number 3, the program should output: * ** *** Try the same, but with the right angle in the top-right, like so (again, for input 3): *** ** * Extension: print out a tree shape of the given size. For example, a tree of size 4 would look like this: * *** ***** ******* * * Calling functions \u00b6 Functions are pre-written bits of code that can be run ('called') at any point. The simplest functions take no parameters and return nothing. For example, the exit function ends your program prematurely: x = 10 while x > 0 : print x x = x - 1 if x == 5 : exit () # not supported in repl.it This will output the numbers 10 to 6, and then stop. Not very useful. However, most functions take input values ('parameters') and output something useful (a 'return value'). For example, the len function returns the length of the given list: my_list = [ 42 , \"BOOMERANG!!!\" , [ 0 , 3 ]] print len ( my_list ) Output: 3 Combined with the range function, which returns a list of numbers in a certain range, you get a list of indices for the list (you might want to look back at that second for example). my_list = [ 42 , \"BOOMERANG!!!\" , [ 0 , 3 ]] print range ( len ( my_list )) Output: [0, 1, 2] The range function can also take multiple parameters: print range ( 5 ) # numbers from 0 to 4. print range ( 2 , 5 ) # numbers from 2 to 4. print range ( 1 , 10 , 2 ) # odd numbers from 1 to 10 Output: [0, 1, 2, 3, 4] [2, 3, 4] [1, 3, 5, 7, 9] There are many built-in functions supplied with Python (see appendix ). Most are in 'modules', collections of functions which have to be imported. For example, the math module contains mathematical functions. To use the sin function, we must import it: import math print math . sin ( math . pi / 2 ) Defining functions \u00b6 Of course, you'll want to make your own functions. To do this, you precede a block of code with a def statement, specifying an [identifier] for the function, and any parameters you might want. For example: def annoy ( num_times ): for i in range ( num_times ): print \"Na na na-na na!\" annoy ( 3 ) The output would be three annoying lines of Na na na-na na! . To return a value, use the return statement. A rather trivial example: def multiply ( x , y ): return x * y print multiply ( 2 , 3 ) Using functions effectively \u00b6 Without functions, most programs would be very hard to read and maintain. Here's an example (admittedly a little contrived): my_string = \"All bees like cheese when they're wearing hats.\" x = 0 for c in my_string : if c == \"a\" : x = x + 1 y = 0 for c in my_string : if c == \"e\" : y = y + 1 Before we explain the example, try and figure out what it does. What do x and y represent? Now, let's refine it with functions: def count_letter ( string , l ): x = 0 for c in string : if c == l : x = x + 1 return x my_string = \"Bees like cheese when they're wearing hats.\" x = count_letter ( my_string , \"a\" ) y = count_letter ( my_string , \"e\" ) This version has a number of advantages: It's far more obvious what the program does. The program is shorter, and cleaner. The code for counting letters in a string is in only one place, and can be reused. The last point has another advantage. There's a bug in this program: upper-case letters aren't counted. It's easy to fix, but in the function version we only have to apply the fix in one place. True, it would only be two places in the original, but in a major program, it could be thousands. You should try and use functions wherever you see multiple lines of code that are repeated, or find yourself writing code to do the same thing (or a similar thing) more than once. In these situations, look at the relevant bits of code and try to think of a way to put it into a function. Concept: Scope \u00b6 When you set a variable inside a function, it will only keep its value inside that function. For example: x = 2 def foo (): x = 3 print \"In foo(), x =\" , x foo () print \"Outside foo(), x =\" , x Output: In foo(), x = 3 Outside foo(), x = 2 This can get quite confusing, so it's best to avoid giving variables inside functions ('local' variables) the same identifier as those outside. If you want to get information out of a function, return it. This concept is called 'scope'. We say that variables which are changed inside a function are in a different scope from those outside. You can have functions within functions, and this can actually be quite useful. In this situation, each nested function will also have its own scope. Exercises: Functions \u00b6 Trigonometry \u00b6 Write a program that takes as input an angle (in radians) and the length of one side (of your choice) of a right-angled triangle. Print out the length of all sides of the triangle. You'll need the functions contained in the math module ( http://docs.python.org/library/math.html ). Note that Python uses radians for its angles. If you are not comfortable with radians, you can use the radians function in the math module to convert to radians from degrees. Extension: you can return multiple values from a function like so: def foo (): return 1 , 2 , 3 x , y , z = foo () Wrap your triangle calculation code in a function. Greeting \u00b6 Write a function that takes a name as an input, and prints a message greeting that person. Average function \u00b6 Wrap the code for your average calculator from the Lists and Loops exercises in a function that takes a list as a parameter and returns its average. What to do next \u00b6 As mentioned at the start, there are loads of Python exercises out there on the Web. If you want to learn some more advanced concepts, there are more tutorials out there too, and http://learnpython.org/ looks like a good choice. Start at the Classes and Objects section. Appendices \u00b6 Operators \u00b6 There are three types of operators in Python: arithmetic, comparison, and logical. I'll list the most important. Arithmetic \u00b6 The usual mathematical order (BODMAS) applies to these, just like in normal algebra. + , - , * , / Self-explanatory (if you're having trouble with division, read the first half of this article: http://www.ferg.org/projects/python_gotchas.html ) '%' Remainder. For example, 5 % 2 is 1, 4 % 2 is 0. ** power (e.g. 4 ** 2 is 4 squared) Comparison \u00b6 These return a boolean ( True or False ) value, and are used in if statements and while loops. These are always done after arithmetic. == , != equal to, not equal to < , <= , > , >= less than, less than or equal to, greater than, etc. in returns true if the string on the left is contained in the string on the right. For example: if \"car\" in \"Scarzy's hair\" : print \"Of course.\" Logical \u00b6 These operators are and , or , and not . They are done after both arithmetic and comparisons. They're pretty self-explanatory, with an example: x = 5 y = 8 z = 2 if x == 5 and y == 3 : print \"True\" else : print \"False\" print x == 5 or not y == 8 # could use y != 8 instead print x == 2 and y == 3 or z == 2 # needs brackets for clarity! Output: False True True When more than one boolean operator is used in an expression, not is performed first (as it works on a single operand). After this, and is done before or , but you should use brackets instead of relying on that fact, for readability. So, the last line of the example should read: print ( x == 2 and y == 3 ) or z == 2 Built-in functions \u00b6 A lot of functions are defined for you by Python. Those listed at http://docs.python.org/library/functions.html are always available, and are the most commonly used, including len , range , and enumerate. Others are contained in modules. To use a function from a module, you must import that module, like so: import math print math . sqrt ( 4 ) One of the most useful modules for the moment will be math ( http://docs.python.org/library/math.html ).","title":"Python: A whirlwind tour"},{"location":"tutorials/python/#python-a-whirlwind-tour","text":"In this tutorial, we'll introduce the basic concepts of programming, which will be central to the programs that you will run on your robot. There are many different languages in which computers can be programmed, all with their advantages and disadvantages, but for the Student Robotics competition we use one called Python 2.6. We chose it because it's good for beginners, but also elegant and powerful. Sprinkled through the tutorial are exercises. The first ones for each section should be quite easy, while the higher-numbered exercises will be harder. Some will be very hard; try these if you're up for a challenge. Before we begin: a word on learning. The way that you learn to code is by doing it; make sure you try out the examples, fiddle with them, break them, try at least one exercise from each section. So, on with the tutorial!","title":"Python: A whirlwind tour"},{"location":"tutorials/python/#using-an-interpreter","text":"To run Python programs you need a something called an interpreter. This is a computer program which interprets human-readable Python code into something that the computer can execute. There are a number of online interpreters that should work even on a locked-down computer such as you will probably find in your college. If your computer has a compatible browser, go to http://repl.it and click Python. Enter your program in the box on the left, and click the arrow to run it. If your browser isn't compatible, another good online interpreter can be found at http://codeskulptor.org . It's very similar; simply enter your program into the left pane and click the play button to run it. The output will appear in the right pane. Whichever you choose, test it with this classic one line program: print \"Hello World!\" The text Hello World! should appear in the output box. There's nothing particularly wrong with online interpreters for our needs, but if you want to use Python for something more advanced you'll want an interpreter which runs directly on your computer. Mac OS X and Linux come with one by default (just type python at the terminal), and you can download the Windows interpreter from http://python.org/download (try Portable Python ( http://portablepython.com ) if you can't install programs on your computer).","title":"Using an interpreter"},{"location":"tutorials/python/#statements","text":"A statement is a line of code that does something. A program is a list of statements. For example: x = 5 y = ( x * 2 ) + 4 print \"Number of bees:\" , y - 2 The statements are executed one by one, in order. This example would give the output Number of bees: 12 . As you may have guessed, the print statement displays text on the screen, while the other two lines are simple algebra.","title":"Statements"},{"location":"tutorials/python/#strings","text":"When you want the interpreter to treat something as a text value (for example, after the print statement above), you have to surround it in quotes. You can use either single ( ' ) or double ( \" ) quotes, but try to be consistent. Pieces of text that are treated like this are called 'strings'.","title":"Strings"},{"location":"tutorials/python/#comments","text":"Placing a hash ( # ) in your program ignores anything after the hash. For example: # This is a comment print \"This isn't.\" # But this is! You should use comments whenever you think that it is not completely clear what a statement or block of statements does, especially as you are working in teams! Also bear in mind the varying coding skills of your team. You might be the best coder in your team, but what if you were taken ill the day before the competition, and your team-mates had to fix your code? Comments are also useful for temporarily removing statements from your code, for testing: x = 42 #x = x - 4 print \"The answer is\" , x This example would output The answer is 42 , as the subtraction is not executed.","title":"Comments"},{"location":"tutorials/python/#variables","text":"Variables store values for later use, as in the first example. They can store many different things, but the most relevant here are numbers, strings (blocks of text), booleans ( True or False ) and lists (which we'll come to later). To set a variable, simply give its name (see [Identifiers], below), followed by = and a value. For example: x = 8 my_string = \"Tall ship\" You can ask the user to put some text into a variable with the raw_input function (we'll cover functions in more detail later): name = raw_input ( \"What is your name?\" )","title":"Variables"},{"location":"tutorials/python/#concept-identifiers","text":"Certain things in your program, for example variables and functions, will need names. These names are called 'identifiers', and must follow these rules: Identifiers can contain letters, digits, and underscores. They may not contain spaces or other symbols. An identifier cannot begin with a digit. Identifiers are case sensitive. This means that bees , Bees and BEES are three different identifiers.","title":"Concept: Identifiers"},{"location":"tutorials/python/#exercises-variables-and-mathematics","text":"","title":"Exercises: Variables and Mathematics"},{"location":"tutorials/python/#average-calculator","text":"The first two lines of this program put two numbers entered by the user into variables a and b . (The input function is like raw_input , but returns a number (e.g. 42 ) when you enter one, rather than a string (like \"42\" ).) Replace the comment with code that averages the numbers and puts them in a variable called average . a = input ( \"Enter first number: \" ) b = input ( \"Enter second number: \" ) # Store the average of a and b in the variable `average` print \"The average of\" , a , \"and\" , b , \"is\" , average Run your code and check that it works.","title":"Average calculator"},{"location":"tutorials/python/#distance-calculator","text":"Write a program which uses input to take an X and a Y coordinate, and calculate the distance from (0, 0) to (X, Y) using Pythagoras' Theorem. Put the code into an interpreter and run it. Does it do what you expected? Hint: you can find the square root of a number by raising it to the power of 0.5, for example, my_number ** 0.5 . Extension: can you adapt the program to calculate the distance between any two points?","title":"Distance calculator"},{"location":"tutorials/python/#booleans-and-if-statements","text":"A boolean value is either True or False . For example: print 42 > 5 print 4 == 2 Output: True False < and == are operators, just like + or * , which return booleans. Others include <= (less than or equal to), > , >= and != (not equal to) (see the Operators appendix). You can also use and , or , and not . if statements execute code only if their condition is true. The code to include in the if is denoted by a number of indented lines (see the concept section on [code blocks][block]). To indent a line, press the tab key or insert four spaces at the start. You can also include an else statement, which is executed if the condition is false. For example: name = raw_input ( \"What is your name?\" ) if name == \"Tim\" : print \"Hello Tim.\" print \"You've got an email.\" else : print \"You're not Tim!\" print \"Python rocks!\" If you typed \"Tim\" at the prompt, this example would output: Hello Tim. You've got an email. Python rocks! Having another if in the else block is very common: price = 50000 * 1.3 if price < 60000 : print \"We can afford the tall ship!\" else : if price < 70000 : print \"We might be able to afford the tall ship...\" else : print \"We can't afford the tall ship. :-(\" So common that there's a special keyword, elif , for the purpose. So, the following piece of code is equivalent to the last: price = 50000 * 1.3 if price < 60000 : print \"We can afford the tall ship!\" elif price < 70000 : print \"We might be able to afford the tall ship...\" else : print \"We can't afford the tall ship. :-(\" Both output: We might be able to afford the tall ship...","title":"Booleans and if statements"},{"location":"tutorials/python/#concept-code-blocks-and-indentation","text":"In the previous section, you probably noticed that the statements 'inside' the if statements were indented relative to the rest of the code. Python is reasonably unique in that it cares about indentation, and uses it to decide which statements are referred to by things like if statements. In most other programming languages, if you don't indent your code it will run just fine, but any poor soul who has to read your code afterwards will hunt you down and hit you around the head with a large, wet fish. In Python, you'll just get an error, which we're sure you'll agree is preferable. A group of consecutive statements that are all indented by the same distance is called a block. if statements, as well as functions and loops, all refer to the block that follows them, which must be indented further than that statement. An example is in order. Let's expand the first if example: name = raw_input ( \"What is your name?\" ) email = \"Bank of Nigeria: Tax Refund\" if name == \"Tim\" : print \"Hello Tim.\" if email != \"\" : print \"You've got an email.\" # (blocks can contain blank lines in the middle) if email != \"Bank of Nigeria: Tax Refund\" : print \"Looks legitimate, too!\" else : print \"No mail.\" else : print \"You're not Tim!\" print \"Python rocks.\" Output (for \"Tim\" as before): Hello Tim. You've got an email! Python rocks. To find the limits of an if statement, just scan straight down until you encounter another statement on the same indent level. Play around with this example until you understand what's happening. One final thing: Python doesn't mind how you indent lines, just so long as you're consistent. Some text editors insert indent characters when you press tab; others insert spaces (normally four). They'll often look the same, but cause errors if they're mixed. If you're using an online interpreter, you probably don't need to worry. Otherwise, check your editor's settings to make sure they're consistent. Four spaces per indent level is the convention in Python. We'll now move on from this topic before that last sentence causes a flame war.","title":"Concept: Code blocks and indentation"},{"location":"tutorials/python/#exercises-if-statements-and-blocks","text":"","title":"Exercises: if Statements and Blocks"},{"location":"tutorials/python/#so-many-ifs","text":"Without running it, work out what output the following code will give: some_text = \"Duct Tape\" if 5 > 4 : print \"Maths works.\" if some_text == \"duct tape\" : print \"The case is wrong.\" elif some_text == \"Duct Tape\" : print \"That's right.\" else : print \"Completely wrong.\" else : print \"Oh-oh.\" Run the code and check your prediction.","title":"So many ifs"},{"location":"tutorials/python/#age-discrimination-tool","text":"Write a program that asks the user for their age, and prints a different message depending on whether they are under 18, over 65, or in between.","title":"Age Discrimination Tool"},{"location":"tutorials/python/#lists","text":"Lists store more than one value in a single variable, and allow you to set and retrieve values by their position ('index') in the list. For example: shopping_list = [ \"Bread\" , \"Milk\" , \"PNP Transistors\" , \"Newspaper\" ] print shopping_list [ 0 ] shopping_list [ 3 ] = \"Magazine\" print shopping_list [ 2 ] print shopping_list [ 3 ] Output: Bread PNP Transistors Magazine Notice that the indices start at 0, not 1. There is a sensible, technical explanation for this that is beyond this tutorial's scope. Also note that because of this, the last element of this four-element list is at index 3. Attempting to retrieve shopping_list[4] would cause an error. You can find out the length of a list with the len function, like so: shopping_list = [ \"Bread\" , \"Milk\" , \"PNP Transistors\" , \"Newspaper\" ] print \"There are\" , len ( shopping_list ), \"items on your list.\" Finally, you can add a value to the end of a list with the append method: shopping_list = [ \"Bread\" , \"Milk\" , \"PNP Transistors\" , \"Newspaper\" ] shopping_list . append ( \"Mince pies in October\" ) print shopping_list The values in a list can be of any type, even other lists. Also, a list can contain values of different types. There are various other useful data structures that are beyond the scope of this tutorial, such as dictionaries (which allow indices other than numbers). You can find out more about these at http://docs.python.org/tutorial/datastructures.html .","title":"Lists"},{"location":"tutorials/python/#while-loops","text":"The while loop is the most basic type of loop. It repeats the statements in the loop while a condition is true. For example: x = 10 while x > 0 : print x if x == 5 : print \"Half way there!\" x = x - 1 print \"Zero!\" Output: 10 9 8 7 6 5 Half way there! 4 3 2 1 Zero! The condition is the same as it would be in an if statement, and the block of code to put in the loop is denoted in the same way, too.","title":"while loops"},{"location":"tutorials/python/#for-loops","text":"The most common application of loops is in conjunction with lists. The for loop is designed specifically for that purpose. For example: shopping_list = [ \"Bread\" , \"Milk\" , \"PNP Transistors\" , \"Newspaper\" ] for x in shopping_list : print \"[ ]\" , x The code is executed once for each item in the list, with x set to each item in turn. So, the output of this example is: [ ] Bread [ ] Milk [ ] PNP Transistors [ ] Newspaper Unfortunately, this method doesn't tell you the index of the current item. x is only a temporary variable, so modifying it has no effect on the list itself (try it). This is where the enumerate function comes in (see the Calling functions section). It tells us the index of each value we loop over. An example with numbers: prices = [ 4 , 5 , 2 , 1.50 ] # Add VAT for index , value in enumerate ( prices ): prices [ index ] = value * 1.20 print prices Output: [4.8, 6.0, 2.4, 1.7999999999999998]","title":"for loops"},{"location":"tutorials/python/#exercises-lists-and-loops","text":"","title":"Exercises: Lists and Loops"},{"location":"tutorials/python/#a-better-average-calculator","text":"Write a program which calculates the average of a list of numbers. You can specify the list in the code. Extension: You can tell when a user has not entered anything at a raw_input prompt when it returns the empty string, \"\" . Otherwise, it returns a string (like \"42.5\"), which you can turn into a number with the float function. For example: var = raw_input ( \"Enter a number: \" ) if var == \"\" : print \"You didn't enter anything!\" else : print \"You entered\" , float ( var ) Now, extend your program to let the user enter the list of values. Stop asking for new list entries when they do not enter anything at the raw_input prompt.","title":"A better average calculator"},{"location":"tutorials/python/#fizz-buzz","text":"Write a program which prints a list of numbers from 0 to 100, but replace numbers divisible by 3 with \"Fizz\", numbers divisible by 5 with \"Buzz\", and numbers divisible by both with \"Fizz Buzz\". Hint: you might find the range function from the next section useful. Extension: create a list of numbers, and replace a number with \"Fuzz\" if it is a multiple of any number in the list.","title":"Fizz buzz"},{"location":"tutorials/python/#trees-and-triangles","text":"You can combine (or 'concatenate') strings in Python with the + operator: str = \"Hello \" str = str + \"World!\" print str Write a program that asks the user for a number, and then prints a triangle of that height, with its right angle at the bottom left. For example, given the number 3, the program should output: * ** *** Try the same, but with the right angle in the top-right, like so (again, for input 3): *** ** * Extension: print out a tree shape of the given size. For example, a tree of size 4 would look like this: * *** ***** ******* * *","title":"Trees and Triangles"},{"location":"tutorials/python/#calling-functions","text":"Functions are pre-written bits of code that can be run ('called') at any point. The simplest functions take no parameters and return nothing. For example, the exit function ends your program prematurely: x = 10 while x > 0 : print x x = x - 1 if x == 5 : exit () # not supported in repl.it This will output the numbers 10 to 6, and then stop. Not very useful. However, most functions take input values ('parameters') and output something useful (a 'return value'). For example, the len function returns the length of the given list: my_list = [ 42 , \"BOOMERANG!!!\" , [ 0 , 3 ]] print len ( my_list ) Output: 3 Combined with the range function, which returns a list of numbers in a certain range, you get a list of indices for the list (you might want to look back at that second for example). my_list = [ 42 , \"BOOMERANG!!!\" , [ 0 , 3 ]] print range ( len ( my_list )) Output: [0, 1, 2] The range function can also take multiple parameters: print range ( 5 ) # numbers from 0 to 4. print range ( 2 , 5 ) # numbers from 2 to 4. print range ( 1 , 10 , 2 ) # odd numbers from 1 to 10 Output: [0, 1, 2, 3, 4] [2, 3, 4] [1, 3, 5, 7, 9] There are many built-in functions supplied with Python (see appendix ). Most are in 'modules', collections of functions which have to be imported. For example, the math module contains mathematical functions. To use the sin function, we must import it: import math print math . sin ( math . pi / 2 )","title":"Calling functions"},{"location":"tutorials/python/#defining-functions","text":"Of course, you'll want to make your own functions. To do this, you precede a block of code with a def statement, specifying an [identifier] for the function, and any parameters you might want. For example: def annoy ( num_times ): for i in range ( num_times ): print \"Na na na-na na!\" annoy ( 3 ) The output would be three annoying lines of Na na na-na na! . To return a value, use the return statement. A rather trivial example: def multiply ( x , y ): return x * y print multiply ( 2 , 3 )","title":"Defining functions"},{"location":"tutorials/python/#using-functions-effectively","text":"Without functions, most programs would be very hard to read and maintain. Here's an example (admittedly a little contrived): my_string = \"All bees like cheese when they're wearing hats.\" x = 0 for c in my_string : if c == \"a\" : x = x + 1 y = 0 for c in my_string : if c == \"e\" : y = y + 1 Before we explain the example, try and figure out what it does. What do x and y represent? Now, let's refine it with functions: def count_letter ( string , l ): x = 0 for c in string : if c == l : x = x + 1 return x my_string = \"Bees like cheese when they're wearing hats.\" x = count_letter ( my_string , \"a\" ) y = count_letter ( my_string , \"e\" ) This version has a number of advantages: It's far more obvious what the program does. The program is shorter, and cleaner. The code for counting letters in a string is in only one place, and can be reused. The last point has another advantage. There's a bug in this program: upper-case letters aren't counted. It's easy to fix, but in the function version we only have to apply the fix in one place. True, it would only be two places in the original, but in a major program, it could be thousands. You should try and use functions wherever you see multiple lines of code that are repeated, or find yourself writing code to do the same thing (or a similar thing) more than once. In these situations, look at the relevant bits of code and try to think of a way to put it into a function.","title":"Using functions effectively"},{"location":"tutorials/python/#concept-scope","text":"When you set a variable inside a function, it will only keep its value inside that function. For example: x = 2 def foo (): x = 3 print \"In foo(), x =\" , x foo () print \"Outside foo(), x =\" , x Output: In foo(), x = 3 Outside foo(), x = 2 This can get quite confusing, so it's best to avoid giving variables inside functions ('local' variables) the same identifier as those outside. If you want to get information out of a function, return it. This concept is called 'scope'. We say that variables which are changed inside a function are in a different scope from those outside. You can have functions within functions, and this can actually be quite useful. In this situation, each nested function will also have its own scope.","title":"Concept: Scope"},{"location":"tutorials/python/#exercises-functions","text":"","title":"Exercises: Functions"},{"location":"tutorials/python/#trigonometry","text":"Write a program that takes as input an angle (in radians) and the length of one side (of your choice) of a right-angled triangle. Print out the length of all sides of the triangle. You'll need the functions contained in the math module ( http://docs.python.org/library/math.html ). Note that Python uses radians for its angles. If you are not comfortable with radians, you can use the radians function in the math module to convert to radians from degrees. Extension: you can return multiple values from a function like so: def foo (): return 1 , 2 , 3 x , y , z = foo () Wrap your triangle calculation code in a function.","title":"Trigonometry"},{"location":"tutorials/python/#greeting","text":"Write a function that takes a name as an input, and prints a message greeting that person.","title":"Greeting"},{"location":"tutorials/python/#average-function","text":"Wrap the code for your average calculator from the Lists and Loops exercises in a function that takes a list as a parameter and returns its average.","title":"Average function"},{"location":"tutorials/python/#what-to-do-next","text":"As mentioned at the start, there are loads of Python exercises out there on the Web. If you want to learn some more advanced concepts, there are more tutorials out there too, and http://learnpython.org/ looks like a good choice. Start at the Classes and Objects section.","title":"What to do next"},{"location":"tutorials/python/#appendices","text":"","title":"Appendices"},{"location":"tutorials/python/#operators","text":"There are three types of operators in Python: arithmetic, comparison, and logical. I'll list the most important.","title":"Operators"},{"location":"tutorials/python/#arithmetic","text":"The usual mathematical order (BODMAS) applies to these, just like in normal algebra. + , - , * , / Self-explanatory (if you're having trouble with division, read the first half of this article: http://www.ferg.org/projects/python_gotchas.html ) '%' Remainder. For example, 5 % 2 is 1, 4 % 2 is 0. ** power (e.g. 4 ** 2 is 4 squared)","title":"Arithmetic"},{"location":"tutorials/python/#comparison","text":"These return a boolean ( True or False ) value, and are used in if statements and while loops. These are always done after arithmetic. == , != equal to, not equal to < , <= , > , >= less than, less than or equal to, greater than, etc. in returns true if the string on the left is contained in the string on the right. For example: if \"car\" in \"Scarzy's hair\" : print \"Of course.\"","title":"Comparison"},{"location":"tutorials/python/#logical","text":"These operators are and , or , and not . They are done after both arithmetic and comparisons. They're pretty self-explanatory, with an example: x = 5 y = 8 z = 2 if x == 5 and y == 3 : print \"True\" else : print \"False\" print x == 5 or not y == 8 # could use y != 8 instead print x == 2 and y == 3 or z == 2 # needs brackets for clarity! Output: False True True When more than one boolean operator is used in an expression, not is performed first (as it works on a single operand). After this, and is done before or , but you should use brackets instead of relying on that fact, for readability. So, the last line of the example should read: print ( x == 2 and y == 3 ) or z == 2","title":"Logical"},{"location":"tutorials/python/#built-in-functions","text":"A lot of functions are defined for you by Python. Those listed at http://docs.python.org/library/functions.html are always available, and are the most commonly used, including len , range , and enumerate. Others are contained in modules. To use a function from a module, you must import that module, like so: import math print math . sqrt ( 4 ) One of the most useful modules for the moment will be math ( http://docs.python.org/library/math.html ).","title":"Built-in functions"}]}